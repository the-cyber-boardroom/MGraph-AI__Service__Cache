# LLM Briefing: HTTP Status Code Refactoring for MGraph-AI__Service__Cache 

date   : 2025-09-17
version: v0.5.30 

## Executive Summary

This document provides guidance for refactoring the MGraph-AI__Service__Cache (v0.5.30) to properly handle HTTP status codes in its Type_Safe FastAPI implementation. The service currently returns dictionary responses with embedded status information rather than using proper HTTP status codes, particularly for cache misses (404 errors). This refactoring will align the service with REST principles while maintaining the Type_Safe architecture that provides runtime validation and domain-specific types throughout the caching system.

## Cache Service Context

The MGraph-AI Cache Service (v0.5.30) is a production serverless caching system with:
- **Five storage strategies**: direct, temporal, temporal_latest, temporal_versioned, semantic_file
- **Content-addressable storage**: SHA256-based hash generation for deduplication
- **Multiple data types**: JSON, string, binary with automatic type detection
- **Namespace isolation**: Complete data isolation between namespaces
- **AWS S3 backend**: Using Memory-FS abstraction for file operations

### Current Implementation in MGraph-AI__Service__Cache

The service has several retrieval methods that need refactoring:
- `retrieve__hash__cache_hash()` - Retrieves by content hash
- `retrieve__id__cache_id()` - Retrieves by cache ID
- `retrieve__json__hash()` - Retrieves JSON specifically
- `retrieve__binary__hash()` - Retrieves binary data

All these methods currently return dictionaries with embedded status information rather than proper HTTP status codes.

## Problem Statement

### Current Implementation Issue

The `retrieve__hash__cache_hash` method in `MGraph-AI__Service__Cache` currently returns a dictionary with status information when a cache miss occurs, but this doesn't translate to proper HTTP status codes:

```python
def retrieve__hash__cache_hash(self, cache_hash, namespace=None) -> Dict[str, Any]:
    result = self.cache_service.retrieve_by_hash(cache_hash, namespace)
    if result is None:
        return {"status": "not_found", "message": "Cache entry not found"}  # Returns 200 OK with error message
```

#### What's Happening Here

When a cache miss occurs (result is `None`), the method returns a dictionary containing error information. However, because this is a normal return (not an exception), FastAPI treats it as a successful response and returns HTTP 200 (OK) to the client. The error information is buried in the response body, requiring clients to parse and interpret the content to determine if their request actually succeeded.

#### Why This Is Problematic

HTTP status codes are a fundamental part of the REST protocol. They provide a standardized way for servers to communicate the result of a request to clients. When we return 200 for a "not found" scenario, we're violating the HTTP specification and REST principles. HTTP 404 (Not Found) exists specifically to indicate that the requested resource doesn't exist.

Additionally, this approach breaks Type_Safe's promise of type safety. The return type `Dict[str, Any]` tells us nothing about the structure of the response. We lose all the benefits of Type_Safe's runtime validation, auto-initialization, and domain-specific types. The `Any` type is essentially giving up on type safety entirely.

### Problems with This Approach

1. **Incorrect HTTP Semantics**: 
   - **What**: Returns HTTP 200 (OK) for a resource that doesn't exist
   - **Why it matters**: Violates HTTP specification and REST principles
   - **Impact**: Breaks standard HTTP client libraries, caching proxies, and CDNs that rely on status codes

2. **Client Confusion**: 
   - **What**: Clients must parse response body to determine if request succeeded
   - **Why it matters**: Every client must implement custom logic instead of using standard HTTP handling
   - **Impact**: Increased client complexity, more error-prone integrations

3. **API Documentation**: 
   - **What**: OpenAPI/Swagger docs don't reflect actual error conditions
   - **Why it matters**: API consumers can't see possible error states in documentation
   - **Impact**: Poor developer experience, increased support burden

4. **Monitoring Issues**: 
   - **What**: HTTP status-based monitoring won't detect failures
   - **Why it matters**: Standard monitoring tools (DataDog, New Relic, CloudWatch) track HTTP status codes
   - **Impact**: Silent failures, missed SLA violations, poor observability

5. **Type Safety Compromise**: 
   - **What**: Mixing error responses with success responses in return type
   - **Why it matters**: Loses Type_Safe's runtime validation and domain modeling benefits
   - **Impact**: Runtime errors, security vulnerabilities from unvalidated data

### The Type_Safe Context

Type_Safe was designed to eliminate entire classes of bugs through runtime type checking and domain-specific primitives. When we use `Dict[str, Any]`, we're abandoning these protections:

- **No Runtime Validation**: The `Any` type bypasses Type_Safe's validation
- **No Auto-initialization**: Type_Safe can't initialize unknown structures
- **No Domain Types**: We lose Safe_Str, Safe_Int, and other protective types
- **No Schema Enforcement**: The structure isn't enforced or documented

## Solution Pattern

### Core Components

The solution leverages Type_Safe's capabilities while integrating with FastAPI's exception handling to achieve proper HTTP semantics without sacrificing type safety.

#### 1. Cache Service Response Schemas

For the MGraph-AI Cache Service specifically, we need schemas that match the existing response patterns while adding proper error handling:

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from memory_fs.schemas.Safe_Str__Cache_Hash import Safe_Str__Cache_Hash
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid import Random_Guid

# Error response for cache misses
class Schema__Cache__Response__Not_Found(Type_Safe):
    status      : Enum__Cache__Client__Response__Status = Enum__Cache__Client__Response__Status.CACHE_MISS
    message     : Safe_Str__Text                       = "Cache entry not found"
    cache_hash  : Safe_Str__Cache_Hash                 = None
    cache_id    : Random_Guid                          = None
    namespace   : Safe_Str__Id                         = None
    strategy    : Enum__Cache__Store__Strategy         = None

# Binary data reference (when binary can't be included in JSON)
class Schema__Cache__Response__Binary_Reference(Type_Safe):
    status       : Enum__Cache__Client__Response__Status = Enum__Cache__Client__Response__Status.CACHE_HIT
    message      : Safe_Str__Text                       = "Binary data requires separate endpoint"
    data_type    : Enum__Cache__Data_Type              = Enum__Cache__Data_Type.BINARY
    size         : Safe_UInt                           
    cache_hash   : Safe_Str__Cache_Hash                
    cache_id     : Random_Guid                         
    namespace    : Safe_Str__Id                        
    strategy     : Enum__Cache__Store__Strategy        
    binary_url   : Safe_Str__Url                       
    metadata     : Dict[str, Any]                      

# Successful retrieval with data
class Schema__Cache__Retrieve__Response(Type_Safe):
    data        : Union[Dict, str, bytes]              # Actual cached content
    metadata    : Schema__Cache__Metadata              # Cache metadata
    data_type   : Enum__Cache__Data_Type              # json|string|binary
```

##### What We're Doing

Create dedicated Type_Safe schemas for different response scenarios:

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text import Safe_Str__Text

class Schema__Cache__Response__Not_Found(Type_Safe):
    status     : Enum__Cache__Client__Response__Status = Enum__Cache__Client__Response__Status.CACHE_MISS
    message    : Safe_Str__Text                       = "Cache entry not found"
    cache_hash : Safe_Str__Cache_Hash                 = None
    namespace  : Safe_Str__Id                         = None

class Schema__Cache__Response__Binary_Reference(Type_Safe):
    status      : Enum__Cache__Client__Response__Status = Enum__Cache__Client__Response__Status.CACHE_HIT
    message     : Safe_Str__Text                       
    data_type   : Enum__Cache__Data_Type              
    size        : Safe_UInt                           
    metadata    : Dict[str, Any]                      
    namespace   : Safe_Str__Id                        
    binary_url  : Safe_Str__Url                       
```

##### Why This Approach

By creating separate Type_Safe schemas for each response scenario, we gain several critical benefits:

1. **Type Safety Throughout**: Each response type is fully validated at runtime. Type_Safe ensures that every field matches its declared type, preventing malformed responses from ever reaching the client.

2. **Auto-initialization**: Type_Safe automatically initializes default values. Notice how `CACHE_MISS` and default messages are set - this prevents null pointer exceptions and ensures consistent error responses.

3. **Domain-Specific Types**: We use `Safe_Str__Text` for messages (sanitized, length-limited), `Safe_Str__Cache_Hash` for hashes (validated format), and `Safe_UInt` for sizes (non-negative). These types prevent entire categories of bugs.

4. **Self-Documenting**: The schema itself documents the response structure. FastAPI can generate OpenAPI documentation directly from these schemas.

##### What This Solves

- **Contract Clarity**: Each response type has a clear, enforceable structure
- **Validation**: All data is validated before being sent to the client
- **Consistency**: Error responses always have the same structure
- **Security**: Safe types prevent injection attacks and data leaks

#### 2. MGraph-AI__Service__Cache Refactored Methods

Here's how to refactor the service's retrieval methods with proper exception handling:

```python
from fastapi import HTTPException
from osbot_utils.type_safe.decorators.type_safe import type_safe

class MGraph_AI__Service__Cache(Type_Safe):
    cache_service : Cache__Service  # The underlying cache service
    
    @type_safe
    def retrieve__hash__cache_hash(self, 
                                   cache_hash : Safe_Str__Cache_Hash,
                                   namespace  : Safe_Str__Id = None
                                   ) -> Schema__Cache__Retrieve__Response:
        """
        Retrieve cache entry by content hash.
        
        This method is called by multiple endpoints:
        - GET /{namespace}/retrieve/hash/{cache_hash}
        - GET /{namespace}/retrieve/hash/{cache_hash}/json
        - GET /{namespace}/retrieve/hash/{cache_hash}/string
        - GET /{namespace}/retrieve/hash/{cache_hash}/binary
        
        Raises:
            HTTPException(404): Cache entry not found
            HTTPException(406): Binary data requested as JSON (Not Acceptable)
        """
        namespace = namespace or Safe_Str__Id("default")
        
        # Attempt retrieval using Memory-FS backend
        result = self.cache_service.retrieve_by_hash(
            cache_hash = cache_hash,
            namespace  = namespace
        )
        
        # Handle cache miss - return 404
        if result is None:
            error_response = Schema__Cache__Response__Not_Found(
                cache_hash = cache_hash,
                namespace  = namespace,
                message    = f"No cache entry found for hash {cache_hash} in namespace {namespace}"
            )
            
            raise HTTPException(
                status_code=404,
                detail=error_response.json()
            )
        
        # Handle binary data that can't be returned in JSON
        if result.get("data_type") == Enum__Cache__Data_Type.BINARY:
            # For binary endpoint, return the data
            # For JSON endpoints, return reference with URL
            if self.request_accepts_binary():  # Check Accept header
                return Schema__Cache__Retrieve__Response(
                    data      = result.get("data"),
                    metadata  = result.get("metadata"),
                    data_type = Enum__Cache__Data_Type.BINARY
                )
            else:
                # Return reference to binary endpoint
                binary_ref = Schema__Cache__Response__Binary_Reference(
                    size       = len(result.get("data", b"")),
                    cache_hash = cache_hash,
                    cache_id   = result.get("metadata", {}).get("cache_id"),
                    namespace  = namespace,
                    strategy   = result.get("metadata", {}).get("strategy"),
                    binary_url = self._build_binary_url(cache_hash, namespace),
                    metadata   = result.get("metadata", {})
                )
                return binary_ref
        
        # Return successful response for JSON/string data
        return Schema__Cache__Retrieve__Response(
            data      = result.get("data"),
            metadata  = result.get("metadata"),
            data_type = result.get("data_type")
        )
    
    @type_safe
    def retrieve__id__cache_id(self,
                               cache_id  : Random_Guid,
                               namespace : Safe_Str__Id = None
                               ) -> Schema__Cache__Retrieve__Response:
        """
        Retrieve cache entry by cache ID.
        
        Cache IDs are unique identifiers generated during storage.
        Unlike hash-based retrieval, ID retrieval is guaranteed unique.
        
        Raises:
            HTTPException(404): Cache ID not found
            HTTPException(410): Cache ID expired (if TTL exceeded)
        """
        namespace = namespace or Safe_Str__Id("default")
        
        # Check ID reference in refs/by-id/
        id_ref = self.cache_service.get_id_reference(cache_id, namespace)
        
        if id_ref is None:
            raise HTTPException(
                status_code=404,
                detail=Schema__Cache__Response__Not_Found(
                    cache_id  = cache_id,
                    namespace = namespace,
                    message   = f"Cache ID {cache_id} not found"
                ).json()
            )
        
        # Check if entry has expired (TTL is 24 hours by default)
        if self._is_expired(id_ref):
            raise HTTPException(
                status_code=410,  # Gone
                detail={
                    "message": "Cache entry has expired",
                    "cache_id": str(cache_id),
                    "expired_at": id_ref.get("ttl_expiry")
                }
            )
        
        # Retrieve using the hash from ID reference
        return self.retrieve__hash__cache_hash(
            cache_hash = id_ref.get("cache_hash"),
            namespace  = namespace
        )

##### Why This Approach

The `@type_safe` decorator is crucial here. It provides:

1. **Parameter Validation**: Every parameter is validated against its type annotation before the method executes. A malformed `cache_hash` never enters the method.

2. **Return Type Checking**: The decorator ensures the return value matches `Schema__Cache__Client__Response`. This catches type mismatches at the service boundary.

3. **Performance Optimization**: Type_Safe's decorator optimizes for methods with few parameters (5x overhead vs 250x for complex signatures).

The `HTTPException` integration is carefully designed:

1. **Proper Status Codes**: The exception carries the HTTP status code (404), which FastAPI automatically converts to the HTTP response status.

2. **Structured Error Details**: The `detail` field contains our Type_Safe schema serialized to JSON. This maintains structure even in error cases.

3. **Stack Preservation**: The exception propagates up through the stack, allowing middleware to intercept if needed.

##### What This Solves

- **HTTP Compliance**: Returns proper 404 status code for missing resources
- **Type Safety**: Maintains full type checking even in error paths
- **Clean Architecture**: Service layer focuses on business logic, not HTTP concerns
- **Testability**: Can test service methods independently of HTTP layer

#### 3. Cache Service Route Handler Integration

The Cache Service has multiple retrieval endpoints that need proper status code handling:

```python
from osbot_fast_api.api.routes.Fast_API__Routes import Fast_API__Routes
from fastapi import Response, Request
from fastapi.responses import Response as FastAPIResponse

class Routes__Cache__Retrieve(Fast_API__Routes):
    tag            = 'cache-retrieve'
    cache_service  : MGraph_AI__Service__Cache
    
    def setup_routes(self):
        """
        Set up all retrieval routes with proper response models and error documentation.
        """
        
        # Generic retrieval (with metadata)
        self.add_route_get(
            self.retrieve_by_hash,
            path="/{namespace}/retrieve/hash/{cache_hash}",
            response_model=Schema__Cache__Retrieve__Response,
            responses={
                404: {"model": Schema__Cache__Response__Not_Found,
                      "description": "Cache entry not found"},
                406: {"model": Schema__Cache__Response__Binary_Reference,
                      "description": "Binary data cannot be returned as JSON"}
            }
        )
        
        # Type-specific retrieval endpoints
        self.add_route_get(
            self.retrieve_json_by_hash,
            path="/{namespace}/retrieve/hash/{cache_hash}/json",
            response_model=Schema__Cache__Client__Response__Json,
            responses={
                404: {"description": "Cache entry not found"},
                415: {"description": "Cache entry is not JSON"}
            }
        )
        
        self.add_route_get(
            self.retrieve_binary_by_hash,
            path="/{namespace}/retrieve/hash/{cache_hash}/binary",
            response_class=Response,
            responses={
                404: {"description": "Cache entry not found"},
                415: {"description": "Cache entry is not binary"}
            }
        )
        
        # ID-based retrieval
        self.add_route_get(
            self.retrieve_by_id,
            path="/{namespace}/retrieve/{cache_id}",
            response_model=Schema__Cache__Retrieve__Response,
            responses={
                404: {"description": "Cache ID not found"},
                410: {"description": "Cache entry expired"}
            }
        )
    
    def retrieve_by_hash(self,
                        cache_hash : Safe_Str__Cache_Hash,
                        namespace  : Safe_Str__Id = "default"
                        ) -> Schema__Cache__Retrieve__Response:
        """
        Retrieve cache entry by hash with metadata.
        
        Returns the cached data along with metadata including storage strategy,
        timestamp, and namespace information.
        """
        return self.cache_service.retrieve__hash__cache_hash(
            cache_hash = cache_hash,
            namespace  = namespace
        )
    
    def retrieve_json_by_hash(self,
                              cache_hash : Safe_Str__Cache_Hash,
                              namespace  : Safe_Str__Id = "default"
                              ) -> Schema__Cache__Client__Response__Json:
        """
        Retrieve JSON data specifically.
        
        Returns:
            200: JSON data retrieved successfully
            404: Cache entry not found
            415: Cache entry exists but is not JSON type
        """
        result = self.cache_service.retrieve__hash__cache_hash(
            cache_hash = cache_hash,
            namespace  = namespace
        )
        
        # Verify data type
        if result.data_type != Enum__Cache__Data_Type.JSON:
            raise HTTPException(
                status_code=415,  # Unsupported Media Type
                detail={
                    "message": f"Cache entry is {result.data_type}, not JSON",
                    "cache_hash": str(cache_hash),
                    "actual_type": str(result.data_type)
                }
            )
        
        return Schema__Cache__Client__Response__Json(
            data        = result.data,
            cache__hash = cache_hash,
            status      = Enum__Cache__Client__Response__Status.CACHE_HIT,
            **result.metadata.json()
        )
    
    def retrieve_binary_by_hash(self,
                                cache_hash : Safe_Str__Cache_Hash,
                                namespace  : Safe_Str__Id = "default"
                                ) -> Response:
        """
        Retrieve binary data directly.
        
        Returns:
            200: Binary data as application/octet-stream
            404: Cache entry not found
            415: Cache entry exists but is not binary type
        """
        result = self.cache_service.retrieve__hash__cache_hash(
            cache_hash = cache_hash,
            namespace  = namespace
        )
        
        # Verify data type
        if result.data_type != Enum__Cache__Data_Type.BINARY:
            raise HTTPException(
                status_code=415,
                detail={
                    "message": f"Cache entry is {result.data_type}, not binary",
                    "cache_hash": str(cache_hash)
                }
            )
        
        # Return binary response with appropriate headers
        return Response(
            content=result.data,
            media_type="application/octet-stream",
            headers={
                "Cache-Control": "public, max-age=86400",  # 24 hour cache
                "X-Cache-Hash": str(cache_hash),
                "X-Cache-Strategy": str(result.metadata.strategy)
            }
        )
```

##### Why This Approach

The route handler is intentionally minimal because:

1. **Separation of Concerns**: HTTP routing logic is separate from business logic. The route handler only knows about HTTP paths and methods.

2. **Exception Propagation**: FastAPI automatically catches `HTTPException` and converts it to the appropriate HTTP response. No manual error handling needed.

3. **Type_Safe Integration**: The OSBot_Fast_API base class (`Fast_API__Routes`) provides Type_Safe integration, ensuring all route parameters and returns are validated.

4. **Documentation Generation**: The `responses` parameter in `setup_routes` tells FastAPI about possible error responses, generating accurate OpenAPI documentation.

##### The Type_Safe Advantage in Routes

When using `Fast_API__Routes` with Type_Safe:

1. **Automatic Serialization**: Type_Safe objects automatically serialize to JSON for responses
2. **Automatic Deserialization**: Request bodies are automatically converted to Type_Safe objects
3. **Path Parameter Validation**: Even path parameters like `cache_hash` use Safe types
4. **Query Parameter Handling**: Optional parameters with defaults work seamlessly

##### What This Solves

- **Clean Architecture**: Routes are thin, testable wrappers
- **Automatic Documentation**: OpenAPI docs show all possible responses
- **Type Safety End-to-End**: From HTTP request to response, types are validated
- **Framework Integration**: Leverages FastAPI's exception handling seamlessly

## Similar Patterns in the Codebase

### 1. Cache__Client Pattern

The `Cache__Client` class demonstrates a similar pattern for handling HTTP responses:

```python
def retrieve_json_by_hash(self, cache_hash: str, namespace: Optional[Safe_Str__Key] = None) -> Schema__Cache__Client__Response:
    namespace = namespace or self.namespace
    url       = f"{self.base_url}/{namespace}/retrieve/hash/{cache_hash}"
    
    with capture_duration() as duration:
        response = requests.get(url, headers=self.headers())
    
    client_response = Schema__Cache__Client__Response(
        data__type   = Enum__Cache__Data_Type.JSON,
        duration     = duration.seconds,
        url          = url,
        status__code = response.status_code
    )
    
    return self.process_response(response=response, client_response=client_response)

def process_response(self, response: Response, client_response: Schema__Cache__Client__Response) -> Schema__Cache__Client__Response:
    if response.status_code == 404:
        return Schema__Cache__Client__Response__Error(
            **client_response.json(),
            status  = Enum__Cache__Client__Response__Status.CACHE_MISS,
            error   = "NOT-FOUND",
            message = "The requested resource was not found."
        )
    # ... handle other status codes
```

#### What's Happening Here

This pattern demonstrates a client-side approach to handling HTTP responses. The `Cache__Client` is making HTTP requests to an external service and needs to handle various response scenarios. It uses Type_Safe's polymorphic schema pattern - different schema classes (`Schema__Cache__Client__Response__Error`, `Schema__Cache__Client__Response__Json`, etc.) all inherit from a base response schema.

#### Why This Pattern Works

1. **Type_Safe Polymorphism**: By using inheritance (`Schema__Cache__Client__Response__Error` extends the base response), Type_Safe maintains type safety while allowing different response structures.

2. **Status Code Preservation**: The HTTP status code is captured in the `client_response` object, allowing downstream code to make decisions based on it.

3. **Duration Tracking**: The `capture_duration()` context manager tracks request time, which is stored in the Type_Safe schema for performance monitoring.

4. **Schema Spreading**: The `**client_response.json()` syntax spreads the base response fields into the error response, maintaining all metadata while adding error-specific fields.

#### Key Type_Safe Features Used

- **Schema Inheritance**: Subclasses inherit and extend parent schema fields
- **Enum Integration**: `Enum__Cache__Client__Response__Status` provides type-safe status values
- **Safe Primitives**: `Safe_Str__Key` for namespace ensures valid identifiers
- **Auto-serialization**: `.json()` method converts Type_Safe objects to dictionaries

### 2. Html__Cache__Manager Pattern

The `Html__Cache__Manager` shows optional value handling:

```python
def retrieve_html(self, url: Safe_Str__Url) -> Optional[str]:
    cache_key  = self._cache_key_for_url(url, CACHE_PREFIX__SITES)
    cache_hash = self._hash_for_cache_key(cache_key)
    
    cached_entry = self.cache_client.retrieve_by_hash(cache_hash, namespace=self.namespace())
    
    if cached_entry and cached_entry.get('status') != 'not_found':
        return cached_entry.get('data')
    return None  # Returns None for not found
```

#### What's Happening Here

This method uses Python's `Optional` type hint to indicate that the method might not return a value. When the cache doesn't contain the requested HTML, it returns `None` rather than raising an exception or returning an error object.

#### Why This Pattern Is Used

1. **Internal API Design**: This is an internal service method, not a REST endpoint. Returning `None` is appropriate for internal APIs where the caller can handle missing data.

2. **Simplicity**: For simple "found/not found" scenarios, `Optional` is cleaner than exceptions or error objects.

3. **Type Safety**: The `Optional[str]` return type makes it explicit that callers must handle the `None` case.

#### When to Use This vs. HTTPException

- **Use Optional for**: Internal methods, library functions, cases where missing data is expected
- **Use HTTPException for**: REST endpoints, user-facing APIs, cases where missing data indicates an error

#### Type_Safe Considerations

While this method returns `Optional[str]`, notice the input uses `Safe_Str__Url`. This ensures:
- URLs are validated and sanitized on input
- Maximum length constraints are enforced
- Malformed URLs are rejected before processing

### 3. Html__Transformations Caching Pattern

Shows cache-miss handling with fallback:

```python
def url__to__html_dict(self, url: Safe_Str__Url, reload: bool = False) -> Schema__Cache__Client__Response__Json:
    if self.use_cache and not (reload or self.force_reload):
        client_response = self.cache_manager.retrieve_html_dict(url)
        if client_response.status == Enum__Cache__Client__Response__Status.CACHE_HIT:
            return client_response
    
    # Cache miss - generate and cache
    html      = self.url__to__html(url, reload=reload)
    html_dict = Html__To__Html_Dict(html=html).convert()
    
    if self.use_cache:
        self.cache_manager.store_html_dict(url, html_dict)
    
    return html_dict
```

#### What's Happening Here

This method implements a "cache-aside" pattern with automatic fallback. It first checks the cache, and on a miss, it generates the data, stores it in the cache, and returns it. The method always returns valid data, never an error.

#### Why This Pattern Is Powerful

1. **Transparent Caching**: Callers don't need to know about caching logic. They always get data.

2. **Self-Healing**: Cache misses automatically populate the cache for next time.

3. **Graceful Degradation**: If caching is disabled (`use_cache = False`), the method still works.

4. **Force Refresh**: The `reload` parameter allows bypassing cache when needed.

#### Type_Safe Benefits in This Pattern

1. **Response Type Consistency**: Always returns `Schema__Cache__Client__Response__Json`, whether from cache or freshly generated.

2. **Enum-Based Status Checking**: Using `Enum__Cache__Client__Response__Status.CACHE_HIT` instead of string comparison prevents typos and enables IDE autocomplete.

3. **Safe URL Handling**: The `Safe_Str__Url` parameter ensures valid URLs, preventing cache poisoning from malformed keys.

#### Pattern Variations

This pattern has several variations in the codebase:
- **Write-Through**: Update cache immediately when data changes
- **Write-Behind**: Update cache asynchronously after changes
- **Refresh-Ahead**: Proactively refresh cache before expiration

## Implementation Guidelines

### 1. When to Use HTTPException

#### What HTTPException Is

`HTTPException` is FastAPI's way of signaling that a request cannot be completed normally. When raised, it immediately stops execution and returns an HTTP error response to the client with the specified status code and details.

#### When to Use It

Use `HTTPException` when:

- **Resource not found (404)**
  - **What**: The requested resource doesn't exist in the system
  - **Why**: HTTP 404 is the standard way to indicate missing resources
  - **Example**: Cache entry, user profile, or document not found
  - **Type_Safe Integration**: Create a `Schema__Not_Found` response with details

- **Unauthorized access (401, 403)**
  - **What**: User lacks authentication (401) or permission (403)
  - **Why**: Security boundaries must be enforced at the API level
  - **Example**: Missing API key, expired token, insufficient permissions
  - **Type_Safe Integration**: Use `Safe_Str__Token` for tokens, validate with Type_Safe decorators

- **Invalid input after validation (400)**
  - **What**: Request is malformed or violates business rules
  - **Why**: Client needs to know what's wrong with their request
  - **Example**: Invalid date range, conflicting parameters
  - **Type_Safe Integration**: Safe types catch most issues, but business logic may find problems

- **Server errors that should be visible to client (500)**
  - **What**: Unexpected server-side failures
  - **Why**: Client needs to know the request failed (not silently corrupted)
  - **Example**: Database connection lost, external service timeout
  - **Type_Safe Integration**: Wrap external calls in try/except, convert to HTTPException

#### How to Structure HTTPException with Type_Safe

```python
from fastapi import HTTPException
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Schema__Error__Details(Type_Safe):
    error_code : Safe_Str__Error_Code
    message    : Safe_Str__Text
    timestamp  : Timestamp_Now
    request_id : Random_Guid

def handle_not_found(resource_type: str, resource_id: str):
    error_details = Schema__Error__Details(
        error_code = f"{resource_type.upper()}_NOT_FOUND",
        message    = f"{resource_type} with id {resource_id} not found"
    )
    
    raise HTTPException(
        status_code=404,
        detail=error_details.json()  # Type_Safe schema to JSON
    )
```

### 2. When to Return Error Schemas

#### What Error Schemas Are

Error schemas are Type_Safe classes that represent error conditions as normal return values rather than exceptions. They're part of the regular response flow.

#### When to Use Them

Return error schemas when:

- **Partial success scenarios**
  - **What**: Some operations succeeded, others failed
  - **Why**: Client needs details about what worked and what didn't
  - **Example**: Batch processing where 8/10 items succeeded
  - **Type_Safe Benefit**: Can model complex partial success states

- **Business logic errors that aren't HTTP errors**
  - **What**: Valid request that violates business rules
  - **Why**: Not an HTTP-level error, but application-level
  - **Example**: Insufficient account balance, quota exceeded
  - **Type_Safe Benefit**: Domain-specific error types with relevant fields

- **Detailed error information needed beyond status code**
  - **What**: Errors requiring structured metadata
  - **Why**: Client needs actionable information to resolve issue
  - **Example**: Validation errors with field-by-field details
  - **Type_Safe Benefit**: Nested schemas can model complex error structures

#### Example of Error Schema Pattern

```python
from typing import List, Union

class Schema__Validation__Error(Type_Safe):
    field      : Safe_Str__Field_Name
    message    : Safe_Str__Text
    suggestion : Safe_Str__Text = None

class Schema__Batch__Result(Type_Safe):
    successful : List[Safe_Str__Id]
    failed     : List[Schema__Validation__Error]
    
    @property
    def has_errors(self) -> bool:
        return len(self.failed) > 0
    
    @property
    def success_rate(self) -> float:
        total = len(self.successful) + len(self.failed)
        return len(self.successful) / total if total > 0 else 0.0
```

### 3. Type_Safe Best Practices

#### Always Use Safe Types

```python
# ❌ WRONG - Raw primitives
def get_user(user_id: str) -> dict:
    pass

# ✅ CORRECT - Safe types throughout
def get_user(user_id: Safe_Str__User_Id) -> Schema__User:
    pass
```

**Why**: Safe types provide:
- **Input Validation**: Malformed IDs rejected immediately
- **SQL Injection Prevention**: Safe_Str sanitizes input
- **Type Domain Separation**: UserID ≠ ProductID at runtime
- **Auto-documentation**: Types document valid values

#### Create Specific Response Schemas

```python
# ❌ WRONG - Generic response
class GenericResponse(Type_Safe):
    data   : Dict[str, Any]
    status : str

# ✅ CORRECT - Specific schemas for each case
class Schema__User__Found(Type_Safe):
    user       : Schema__User
    last_login : Timestamp_Now
    
class Schema__User__Not_Found(Type_Safe):
    user_id    : Safe_Str__User_Id
    searched_at: Timestamp_Now
    suggestion : Safe_Str__Text = "Check if user ID is correct"
```

**Why Specific Schemas**:
- **Compile-Time Checking**: IDEs can autocomplete fields
- **Runtime Validation**: Type_Safe validates structure
- **Documentation**: Each schema documents its purpose
- **Refactoring Safety**: Changes propagate through codebase

#### Use Enums for Status Values

```python
from enum import Enum

class Enum__Response__Status(str, Enum):
    SUCCESS   = "success"
    PARTIAL   = "partial"
    FAILED    = "failed"
    
    def is_error(self) -> bool:
        return self == self.FAILED

class Schema__Response(Type_Safe):
    status : Enum__Response__Status  # Not just 'str'
```

**Why Enums**:
- **Typo Prevention**: Can't accidentally use "sucess"
- **Autocomplete**: IDEs suggest valid values
- **Refactoring**: Rename values in one place
- **Type_Safe Integration**: Enums serialize/deserialize automatically

#### Document Raises in Docstrings

```python
@type_safe
def delete_cache_entry(self, 
                      entry_id: Safe_Str__Cache_Id
                      ) -> Schema__Delete__Result:
    """
    Delete a cache entry permanently.
    
    Args:
        entry_id: The cache entry identifier
    
    Returns:
        Schema__Delete__Result with deletion details
        
    Raises:
        HTTPException(404): Entry not found
        HTTPException(403): Insufficient permissions
        HTTPException(409): Entry locked by another process
    """
```

**Why Document Raises**:
- **API Clarity**: Developers know what exceptions to handle
- **Testing Coverage**: Testers know what error cases to verify
- **Client Development**: Frontend devs can handle all error cases
- **OpenAPI Generation**: Tools can generate accurate API docs

#### Keep Route Handlers Thin

```python
# ❌ WRONG - Business logic in route
@app.get("/users/{user_id}")
def get_user(user_id: str):
    # 50 lines of business logic here
    if not validate_user_id(user_id):
        raise HTTPException(400, "Invalid user ID")
    
    user = db.query(f"SELECT * FROM users WHERE id = {user_id}")
    # More logic...

# ✅ CORRECT - Thin route handler
class Routes__Users(Fast_API__Routes):
    user_service: Service__Users
    
    def get_user(self, user_id: Safe_Str__User_Id) -> Schema__User:
        return self.user_service.get_user_by_id(user_id)
```

**Why Thin Routes**:
- **Testability**: Can test service without HTTP
- **Reusability**: Service methods usable elsewhere
- **Separation**: HTTP concerns separate from business logic
- **Type_Safe Benefits**: Services use full Type_Safe validation

### 4. Testing Considerations

#### Testing HTTPException Handling

```python
import pytest
from fastapi import HTTPException

def test_retrieve_not_found():
    service = MGraph_AI__Service__Cache()
    
    # Test that exception is raised
    with pytest.raises(HTTPException) as exc_info:
        service.retrieve__hash__cache_hash(
            cache_hash="non-existent-hash"
        )
    
    # Verify status code
    assert exc_info.value.status_code == 404
    
    # Verify error details structure
    error_detail = exc_info.value.detail
    assert "not found" in error_detail["message"].lower()
    assert error_detail["status"] == "CACHE_MISS"
    
    # Verify Type_Safe schema structure
    error_schema = Schema__Cache__Response__Not_Found.from_json(error_detail)
    assert error_schema.cache_hash == "non-existent-hash"
```

#### Testing Type_Safe Response Schemas

```python
def test_response_schema_validation():
    # Test successful response
    response = Schema__Cache__Client__Response__Json(
        cache__hash = "abc123",
        status      = Enum__Cache__Client__Response__Status.CACHE_HIT,
        data        = {"key": "value"}
    )
    
    # Verify Type_Safe auto-initialization
    assert response.timestamp is not None  # Timestamp_Now auto-generated
    assert isinstance(response.cache__hash, Safe_Str__Cache_Hash)
    
    # Test JSON serialization round-trip
    json_data = response.json()
    restored = Schema__Cache__Client__Response__Json.from_json(json_data)
    assert restored.cache__hash == response.cache__hash
    assert restored.status == response.status
```

#### Integration Testing with FastAPI TestClient

```python
from fastapi.testclient import TestClient

def test_api_returns_404():
    client = TestClient(app)
    
    response = client.get("/cache/retrieve/hash/non-existent")
    
    # Verify HTTP status
    assert response.status_code == 404
    
    # Verify response structure matches Type_Safe schema
    error_data = response.json()
    error_schema = Schema__Cache__Response__Not_Found.from_json(error_data)
    assert error_schema.status == Enum__Cache__Client__Response__Status.CACHE_MISS
```

**Why This Testing Approach**:
- **Layer Isolation**: Test service logic separately from HTTP
- **Type Verification**: Ensure Type_Safe schemas work correctly
- **Contract Testing**: Verify API contract matches documentation
- **Error Path Coverage**: Test all exception scenarios

## Migration Strategy for MGraph-AI__Service__Cache

### Phase 1: Add New Methods with Proper Exception Handling
1. Create new methods with `_v2` suffix that use HTTPException
2. Keep existing methods for backward compatibility
3. Mark old methods as deprecated with warnings

```python
class MGraph_AI__Service__Cache(Type_Safe):
    
    @deprecated("Use retrieve__hash__cache_hash_v2 - returns proper HTTP status codes")
    def retrieve__hash__cache_hash(self, cache_hash, namespace=None) -> Dict[str, Any]:
        """Legacy method - returns dict with status field"""
        result = self.cache_service.retrieve_by_hash(cache_hash, namespace)
        if result is None:
            return {"status": "not_found", "message": "Cache entry not found"}
        return result
    
    @type_safe
    def retrieve__hash__cache_hash_v2(self, 
                                      cache_hash : Safe_Str__Cache_Hash,
                                      namespace  : Safe_Str__Id = None
                                      ) -> Schema__Cache__Retrieve__Response:
        """New method with proper HTTP exception handling"""
        # Implementation with HTTPException as shown above
```

### Phase 2: Update Route Handlers
1. Create new route definitions using v2 methods
2. Update OpenAPI documentation with proper response codes
3. Test with existing clients to ensure compatibility

### Phase 3: Update Consumers
1. Update internal consumers to handle HTTPException
2. Update Cache__Client to handle 404 status codes properly
3. Update documentation and examples

### Phase 4: Remove Legacy Methods
1. After confirming all consumers updated (check CloudWatch logs)
2. Remove deprecated methods
3. Rename `_v2` methods to original names
4. Update route paths if versioned

## Benefits of This Pattern

### 1. Correct HTTP Semantics

**What This Means**: The API returns appropriate HTTP status codes that match the actual result of the operation.

**Why It Matters**: HTTP status codes are a universal language understood by:
- **Browsers**: Automatically retry on 503, cache 304 responses, show error pages for 404
- **Load Balancers**: Route traffic based on 5xx errors, health checks use 200
- **CDNs**: Cache based on status codes, invalidate on 404
- **Monitoring Tools**: Alert on 4xx/5xx spikes, track success rates

**Type_Safe Integration**: Even with proper status codes, response bodies remain fully typed and validated, giving clients both standard HTTP signals and rich error details.

### 2. Type Safety Throughout

**What This Means**: Every piece of data flowing through the system is validated against Type_Safe schemas.

**The Type_Safe Advantage**:
```python
# Without Type_Safe - Runtime errors waiting to happen
def process(data: dict) -> dict:
    user_id = data["user_id"]  # KeyError possible
    amount = float(data["amount"])  # ValueError possible
    return {"result": user_id * amount}  # TypeError possible

# With Type_Safe - Errors caught at boundaries
def process(data: Schema__Request) -> Schema__Response:
    # data.user_id guaranteed to exist and be Safe_Str__User_Id
    # data.amount guaranteed to be Safe_Float__Money
    return Schema__Response(result=calculate(data))
```

**Why It Matters**: Type_Safe catches errors at the earliest possible point - when data enters the system, not when it's used deep in business logic.

### 3. Clear API Contract

**What This Means**: The API's behavior is fully documented through Type_Safe schemas and OpenAPI specifications.

**How Type_Safe Enhances This**:
- **Schema as Documentation**: Each Type_Safe class documents expected fields and types
- **Enum Values**: Possible values are enumerated in the schema
- **Safe Type Constraints**: `Safe_Str__Email` tells clients exactly what's valid
- **Default Values**: Type_Safe's auto-initialization shows expected defaults

**Client Benefits**:
```typescript
// Generated TypeScript from OpenAPI + Type_Safe schemas
interface CacheResponse {
  cache_hash: string;  // max 16 chars, hex only
  status: "CACHE_HIT" | "CACHE_MISS";  // exhaustive enum
  data?: any;  // present only on CACHE_HIT
}
```

### 4. Better Monitoring

**What This Means**: Standard monitoring tools work without custom configuration.

**Metrics Available with Proper Status Codes**:
- **Success Rate**: 2xx responses / total responses
- **Error Rate**: 4xx + 5xx responses / total responses
- **Not Found Rate**: 404 responses / total responses
- **Server Error Rate**: 5xx responses / total responses

**Type_Safe Bonus**: Response schemas can include timing data:
```python
class Schema__Response(Type_Safe):
    duration_ms : Safe_Float  # Process time
    timestamp   : Timestamp_Now  # Auto-generated
    cache_hit   : bool
```

### 5. Client Simplicity

**What This Means**: Clients can use standard HTTP libraries without custom error parsing.

**Without This Pattern**:
```javascript
// Client must parse body to detect errors
const response = await fetch('/api/cache/retrieve/xyz');
const data = await response.json();
if (data.status === 'not_found') {  // Custom error handling
    handleNotFound();
}
```

**With This Pattern**:
```javascript
// Standard HTTP handling
const response = await fetch('/api/cache/retrieve/xyz');
if (response.status === 404) {  // Standard HTTP
    handleNotFound();
} else if (response.ok) {
    const data = await response.json();
    // Type-safe data guaranteed
}
```

### 6. Separation of Concerns

**What This Means**: Each layer has a single, clear responsibility.

**Layer Responsibilities with Type_Safe**:

1. **Route Layer**: HTTP routing, parameter extraction
   - Uses Type_Safe for parameter validation
   - Thin wrapper around service

2. **Service Layer**: Business logic, orchestration
   - Uses Type_Safe schemas for data structures
   - Raises HTTPException for HTTP errors

3. **Data Layer**: Storage, retrieval
   - Uses Type_Safe for data models
   - Returns Optional or raises domain exceptions

**Why This Matters**: Each layer can be developed, tested, and maintained independently while Type_Safe ensures consistent data structures across all layers.

## Common Pitfalls to Avoid

### 1. Returning None from REST Endpoints

**The Pitfall**:
```python
@app.get("/user/{user_id}")
def get_user(user_id: str) -> Optional[Schema__User]:
    return None  # ❌ What's the HTTP response for None?
```

**Why It's Bad**: 
- FastAPI converts `None` to `null` in JSON with 200 status
- Clients receive `200 OK` with `null` body - ambiguous
- Is it "not found" or "found but empty"?

**The Right Way**:
```python
@app.get("/user/{user_id}")
def get_user(user_id: Safe_Str__User_Id) -> Schema__User:
    user = find_user(user_id)
    if not user:
        raise HTTPException(404, detail={"message": "User not found"})
    return user
```

**Type_Safe Benefit**: Using specific return types (not Optional) makes the contract clear.

### 2. Mixing HTTP and Business Logic Concerns

**The Pitfall**:
```python
class UserService(Type_Safe):
    def create_user(self, email: str) -> dict:
        if not "@" in email:
            return {"status_code": 400, "error": "Invalid email"}  # ❌ HTTP in service
```

**Why It's Bad**:
- Service layer shouldn't know about HTTP
- Can't reuse service in non-HTTP contexts (CLI, queue workers)
- Testing requires HTTP mocking

**The Right Way**:
```python
class UserService(Type_Safe):
    def create_user(self, email: Safe_Str__Email) -> Schema__User:
        # Safe_Str__Email already validated email format
        # Business logic only
        return create_user_in_db(email)

class Routes__Users(Fast_API__Routes):
    def create_user(self, email: Safe_Str__Email) -> Schema__User:
        try:
            return self.service.create_user(email)
        except BusinessRuleViolation as e:
            raise HTTPException(400, detail=str(e))
```

### 3. Using Generic Exceptions

**The Pitfall**:
```python
if not found:
    raise Exception("Not found")  # ❌ Generic exception
```

**Why It's Bad**:
- No HTTP status code information
- Can't distinguish between different error types
- Stack traces don't indicate intent

**The Right Way**:
```python
# Define domain exceptions
class CacheEntryNotFound(Exception):
    def __init__(self, cache_hash: Safe_Str__Cache_Hash):
        self.cache_hash = cache_hash
        super().__init__(f"Cache entry {cache_hash} not found")

# Service raises domain exception
if not found:
    raise CacheEntryNotFound(cache_hash)

# Route converts to HTTP
try:
    return service.retrieve(cache_hash)
except CacheEntryNotFound as e:
    raise HTTPException(404, detail={"cache_hash": str(e.cache_hash)})
```

### 4. Losing Type Safety in Error Paths

**The Pitfall**:
```python
def handle_error(error: Exception) -> dict:
    return {
        "error": str(error),  # ❌ Untyped dictionary
        "timestamp": datetime.now().isoformat()
    }
```

**Why It's Bad**:
- Error responses aren't validated
- Structure can vary between errors
- Clients can't rely on response format

**The Right Way**:
```python
class Schema__Error(Type_Safe):
    error_type : Safe_Str__Error_Type
    message    : Safe_Str__Text
    timestamp  : Timestamp_Now  # Auto-generated
    request_id : Random_Guid    # Auto-generated

def handle_error(error: Exception) -> Schema__Error:
    return Schema__Error(
        error_type = type(error).__name__,
        message    = str(error)
    )
```

### 5. Undocumented Error Cases

**The Pitfall**:
```python
def delete_item(item_id: str):
    """Delete an item"""
    # Hidden exceptions not documented
    if not authorized():
        raise HTTPException(403)
    if locked():
        raise HTTPException(409)
```

**Why It's Bad**:
- Clients don't know what errors to handle
- API documentation is incomplete
- Testing misses error cases

**The Right Way**:
```python
def delete_item(item_id: Safe_Str__Item_Id) -> Schema__Delete__Result:
    """
    Delete an item from the cache.
    
    Args:
        item_id: Unique identifier of the item
        
    Returns:
        Schema__Delete__Result with confirmation
        
    Raises:
        HTTPException(403): User lacks delete permission
        HTTPException(404): Item not found
        HTTPException(409): Item is locked by another process
        HTTPException(503): Storage service unavailable
    """
```

**Type_Safe Integration**: Document which Safe types can raise validation errors:
```python
    Args:
        item_id: Safe_Str__Item_Id (validates format: alphanumeric + hyphen, max 64 chars)
```

## Conclusion and Implementation Checklist

This refactoring pattern provides a clean, type-safe way to handle HTTP status codes in the MGraph-AI Cache Service while maintaining the benefits of the Type_Safe framework. By using `HTTPException` at the service layer and proper response schemas, we achieve correct HTTP semantics without compromising the type safety that makes the Cache Service robust and secure.

### Implementation Checklist for MGraph-AI__Service__Cache Refactoring

#### Phase 1: Schema Creation
- [ ] Create `Schema__Cache__Response__Not_Found` for 404 responses
- [ ] Create `Schema__Cache__Response__Binary_Reference` for binary data references
- [ ] Create `Schema__Cache__Response__Expired` for 410 Gone responses
- [ ] Update existing response schemas to inherit from common base
- [ ] Add proper Type_Safe validation to all response schemas

#### Phase 2: Service Layer Refactoring
- [ ] Add `_v2` versions of retrieval methods with HTTPException
- [ ] Implement `retrieve__hash__cache_hash_v2()` with proper 404 handling
- [ ] Implement `retrieve__id__cache_id_v2()` with 404 and 410 handling
- [ ] Add type-specific retrieval methods (JSON, string, binary)
- [ ] Implement semantic_file strategy specific error handling
- [ ] Add `@deprecated` decorators to old methods

#### Phase 3: Route Handler Updates
- [ ] Update `Routes__Cache__Retrieve` to use new service methods
- [ ] Add proper `responses` parameter to all route definitions
- [ ] Implement content negotiation for binary vs JSON responses
- [ ] Add appropriate cache headers to responses
- [ ] Update OpenAPI documentation generation

#### Phase 4: Testing
- [ ] Unit tests for all HTTPException scenarios
- [ ] Integration tests with TestClient for each endpoint
- [ ] Test all five storage strategies (direct, temporal, etc.)
- [ ] Test namespace isolation with proper 404s
- [ ] Performance tests to ensure no regression

#### Phase 5: Consumer Updates
- [ ] Update `Cache__Client` to handle HTTP status codes
- [ ] Update `Html__Cache__Manager` error handling
- [ ] Update any internal services using the cache
- [ ] Update documentation and API examples
- [ ] Update monitoring dashboards for new status codes

#### Phase 6: Deployment and Migration
- [ ] Deploy v2 methods alongside existing methods
- [ ] Monitor CloudWatch for usage patterns
- [ ] Gradually migrate consumers to v2 endpoints
- [ ] Verify no 500 errors from missing error handling
- [ ] Remove deprecated methods after full migration

### Key Benefits for Cache Service

1. **Correct HTTP Semantics**: Cache misses return 404, expired entries return 410
2. **Type Safety**: All responses validated through Type_Safe schemas
3. **Better Monitoring**: CloudWatch can track cache hit rates via status codes
4. **Storage Strategy Awareness**: Different strategies can have specific error handling
5. **Namespace Isolation**: Clear 404s when accessing wrong namespace
6. **Binary Data Handling**: Proper content negotiation between JSON and binary

### Cache Service Specific Considerations

- **Hash Collisions**: While unlikely with SHA256, proper error messages help debug
- **TTL Expiration**: 410 Gone status clearly indicates expired entries
- **Namespace Security**: 404s don't leak information about other namespaces
- **Storage Strategy Selection**: 400 Bad Request for invalid strategy combinations
- **Semantic Paths**: Clear error messages for invalid path structures

The pattern is already partially implemented in related services like `Cache__Client` and can be systematically applied across the MGraph-AI Cache Service codebase for consistent, type-safe error handling that maintains the service's high reliability standards.