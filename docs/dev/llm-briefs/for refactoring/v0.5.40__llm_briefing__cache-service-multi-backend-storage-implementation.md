# LLM Briefing: Cache Service Multi-Backend Storage Implementation

**date**: 22 Sep 2025

## Problem Statement

The MGraph-AI Cache Service was tightly coupled to AWS S3 storage, causing several issues:

1. **Test Performance**: Unit tests took 15+ seconds due to LocalStack/S3 setup overhead
2. **Development Friction**: Required AWS credentials or LocalStack even for simple local development
3. **Deployment Constraints**: Couldn't run in environments without S3 access (edge computing, air-gapped systems)
4. **Namespace Isolation Bug**: Discovered that namespace isolation only worked for S3 backend due to its `s3_prefix` feature, but would fail for other storage backends, causing data collision between namespaces

## Solution Architecture

Leveraged the existing Memory-FS abstraction layer to support multiple storage backends (Memory, S3, Local Disk, SQLite, ZIP) with automatic detection and configuration. The key insight was that Memory-FS already provided the abstraction needed - we just needed to wire it up properly.

### Critical Design Fix
Instead of handling namespaces at the storage backend level (which only worked for S3), we identified that the correct approach is to use Memory-FS's `Path__Handler.prefix_path` mechanism, which works uniformly across all backends.

## Current Implementation Status

### Completed Components

1. **`Enum__Cache__Storage_Mode`**: Defines available storage backends (MEMORY, S3, LOCAL_DISK, SQLITE, ZIP)

2. **`Cache__Config`**: 
   - Centralized configuration management
   - Auto-detects optimal storage mode (defaults to memory, uses S3 if AWS credentials found)
   - Creates appropriate storage backend instances
   - Handles environment variable configuration

3. **`Cache__Handler`** (Updated):
   - Accepts `storage_backend` and `namespace` parameters
   - **CRITICAL FIX NEEDED**: Must use `prefix_path` in all path handlers to include namespace, not the current `create_namespaced_storage()` approach
   - Example fix: `prefix_path = f"{namespace}/{base_path}"` for all handlers

4. **`Cache__Service`** (Updated):
   - Uses `Cache__Config` for configuration
   - Shares single storage backend across all handlers
   - Maintains identical API regardless of backend
   - Added `get_storage_info()` method

5. **`Routes__Store`** (Proposed):
   - Add `/storage/info` endpoint to expose current storage configuration

## Next Steps

### 1. Fix Namespace Isolation (PRIORITY)
Update `Cache__Handler.setup()` to include namespace in all path handler prefix_paths:
```python
def _build_prefixed_path(self, base_path: str) -> str:
    return f"{self.namespace}/{base_path}" if self.namespace else base_path

# Then use for all handlers:
kwargs = dict(prefix_path = self._build_prefixed_path(CACHE__HANDLER__PREFIX_PATH__FS__REFS_HASH))
```

### 2. Update Test Structure
Reorganize tests into three tiers:
- `/tests/unit/*` - Memory mode only, no external dependencies (expected: <1s total)
- `/tests/integration/*` - LocalStack with S3 emulation (expected: 5-10s)
- `/tests/qa/*` - Live AWS environment testing (real latency)

### 3. Update Existing Tests
- Modify `Service__Fast_API__Test_Objs` to use memory mode by default
- Update all unit tests to explicitly use `Enum__Cache__Storage_Mode.MEMORY`
- Create base test classes that auto-configure based on directory structure
- Fix any tests that assume S3-specific behavior

### 4. Create Integration Tests
- Test S3-specific features (pre-signed URLs, lifecycle policies)
- Test storage backend switching
- Verify namespace isolation across all backends
- Test error handling and retry logic

### 5. Performance Validation
- Benchmark memory mode performance (target: 100+ ops/ms)
- Verify 50-100x speedup in unit test execution
- Profile memory usage in different modes

### 6. Documentation Updates
- Update README with storage mode configuration
- Add deployment guides for different scenarios
- Document environment variables and their effects

## Expected Outcomes

Once fully implemented:
- Unit tests will run in <1 second (from current 15+ seconds)
- Development environment won't require any AWS setup
- Service can run in memory-only mode for ephemeral workloads
- True namespace isolation across all storage backends
- Easy switching between storage modes via environment variables

## Configuration Summary

Environment variables:
- `CACHE__SERVICE__STORAGE_MODE`: Explicit mode selection
- `CACHE__SERVICE__BUCKET_NAME`: S3 bucket (S3 mode only)
- `CACHE__SERVICE__LOCAL_DISK_PATH`: Local storage path
- `CACHE__SERVICE__SQLITE_PATH`: SQLite DB path (`:memory:` for in-memory)
- `CACHE__SERVICE__ZIP_PATH`: ZIP archive path

The implementation maintains full backward compatibility while enabling dramatic performance improvements and deployment flexibility.