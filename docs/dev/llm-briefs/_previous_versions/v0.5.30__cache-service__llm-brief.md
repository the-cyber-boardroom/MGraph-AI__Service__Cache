# MGraph-AI Cache Service - LLM Brief 

**version**: v0.5.30

## Service Overview
The MGraph-AI Cache Service is a production-ready, serverless caching system designed for AWS Lambda deployment. It provides intelligent content-addressable storage with multiple caching strategies, backed by AWS S3 with Memory-FS abstraction layer.

## Core Architecture

### Service Structure
- **FastAPI-based**: Built on `osbot-fast-api-serverless` framework
- **AWS Lambda optimized**: Includes dependency loading and cold-start optimization
- **Type-safe**: Extensive use of `Type_Safe` classes for validation
- **Modular design**: Clear separation between service, storage, and API layers

### Storage Backend
- **S3 Storage**: Primary backend via `Storage_FS__S3` class
- **Memory-FS abstraction**: File system operations through `Memory_FS` library
- **Path sharding**: Automatic 2-level hash sharding for S3 performance
- **Namespace isolation**: Each namespace maps to an S3 prefix

## Storage Strategies

The service implements five distinct storage strategies through different `Memory_FS` implementations:

### 1. Direct (`direct`)
- Simple hash-based storage at `data/direct/`
- Uses `Memory_FS` with `Path__Handler__Hash_Sharded`
- Best for: Simple key-value storage without versioning

### 2. Temporal (`temporal`)
- Time-organized storage at `data/temporal/`
- Uses `Memory_FS__Temporal` for automatic timestamping
- Best for: Time-series data, audit logs

### 3. Temporal Latest (`temporal_latest`)
- Temporal storage with latest pointer at `data/temporal-latest/`
- Uses `Memory_FS__Latest_Temporal`
- Best for: Frequently updated content where you need both history and quick latest access

### 4. Temporal Versioned (`temporal_versioned`)
- Full versioning system at `data/temporal-versioned/`
- Maintains versions at `data/temporal-versioned/versions/`
- Uses combined handlers: temporal, latest, and versioned
- Best for: Complete version history with rollback capability

### 5. Semantic File (`semantic_file`) **NEW in v0.5.30**
- Semantic path-based storage at `data/semantic-file/`
- Uses `Path__Handler__Semantic_File` for custom path organization
- Requires both `cache_key` (used as file path) and optionally `file_id`
- Best for: Human-readable paths, organized folder structures, predictable file locations

## API Endpoints

### Storage Operations

#### String Storage
```
# Basic (auto-generated hash)
POST /{namespace}/{strategy}/store/string

# With custom cache key (NEW in v0.5.30)
POST /{namespace}/{strategy}/store/string/{cache_key:path}
```
- Body: Raw string data
- Auto-generates hash from content or uses provided cache_key
- Optional `file_id` parameter for custom file naming
- Returns: `Schema__Cache__Store__Response`

#### JSON Storage
```
# Basic (auto-generated hash)
POST /{namespace}/{strategy}/store/json

# With custom cache key (NEW in v0.5.30)
POST /{namespace}/{strategy}/store/json/{cache_key:path}
```
- Body: JSON object
- Sorted keys for consistent hashing
- Optional `file_id` parameter for custom file naming
- Returns: `Schema__Cache__Store__Response`

#### Binary Storage
```
# Basic (auto-generated hash)
POST /{namespace}/{strategy}/store/binary

# With custom cache key (NEW in v0.5.30)
POST /{namespace}/{strategy}/store/binary/{cache_key:path}
```
- Body: Raw binary data
- Supports `Content-Encoding: gzip` header
- Auto-decompresses for hash calculation if compressed
- Optional `file_id` parameter for custom file naming
- Returns: `Schema__Cache__Store__Response`

### Retrieval Operations

#### Generic Retrieval (with metadata)
```
GET /{namespace}/retrieve/hash/{cache_hash}
GET /{namespace}/retrieve/{cache_id}
GET /{namespace}/retrieve/details/{cache_id}
GET /{namespace}/retrieve/details/all/{cache_id}
```
- Returns data with type information and metadata
- Binary data returns URL redirect instead of inline data
- Details endpoints provide configuration and reference information

#### Type-Specific Retrieval
```
# By ID
GET /{namespace}/retrieve/{cache_id}/string
GET /{namespace}/retrieve/{cache_id}/json
GET /{namespace}/retrieve/{cache_id}/binary

# By Hash
GET /{namespace}/retrieve/hash/{cache_hash}/string
GET /{namespace}/retrieve/hash/{cache_hash}/json
GET /{namespace}/retrieve/hash/{cache_hash}/binary
```
- Returns data in appropriate format
- Binary endpoints return `application/octet-stream`
- String endpoints return `text/plain`
- JSON endpoints return parsed JSON

### Management Operations
```
GET /{namespace}/exists/hash/{cache_hash}
GET /{namespace}/file-hashes
GET /{namespace}/file-ids
GET /{namespace}/stats
GET /server/namespaces
DELETE /{namespace}/delete/{cache_id}
```

### Storage Admin Operations
```
GET /admin/storage/bucket-name
GET /admin/storage/file/exists/{path:path}
GET /admin/storage/file/bytes/{path:path}
GET /admin/storage/file/json/{path:path}
GET /admin/storage/files/parent-path
GET /admin/storage/files/all/{path:path}
GET /admin/storage/folders
```

### Service Information
```
GET /info/health          # Returns: {'status': 'ok'}
GET /info/server          # Server info including Fast_API details
GET /info/status          # Service status with environment
GET /info/versions        # All dependency versions
```

## Enhanced Path Control (NEW in v0.5.30)

### Semantic File Strategy
The `semantic_file` strategy enables full control over file paths within the cache:

```python
# Example: Organizing files by project and date
POST /production/semantic_file/store/json/projects/alpha/2025/01?file_id=config.ext
Body: {"settings": {...}}

# This creates a file at:
# data/semantic-file/projects/alpha/2025/01/config_ext.json   (cache_key='projects/alpha/2025/01', file_id = 'config_ext' (sanitized via Safe_Str__Id)  
```

### Custom File IDs
All storage endpoints now support an optional `file_id` parameter:

```python
# Example: Using custom file_id with temporal strategy
POST /production/temporal/store/json/user/preferences?file_id=user-12345
Body: {"theme": "dark", "language": "en"}

# Creates files with 'user-12345' as the identifier instead of auto-generated UUID
```

### Combined Cache Key and File ID
For maximum flexibility, combine `cache_key` (path) with `file_id`:

```python
# Example: Semantic path with custom identifier
POST /production/semantic_file/store/json/reports/monthly/sales?file_id=2025-01-sales
Body: {"revenue": 150000, "units": 500}

# Creates: data/semantic-file/reports/monthly/sales/2025-01-sales.json
```

## Data Model

### Cache Hash (`Safe_Str__Cache_Hash`)
- Format: Lowercase hexadecimal, 10-96 characters
- Default length: 16 characters
- Configurable via `Cache__Hash__Config`
- Algorithms: MD5, SHA256 (default), SHA384

### Cache ID (`Random_Guid`)
- Format: Standard UUID/GUID
- Unique per storage operation
- Used for direct retrieval and deletion

### Storage Structure

#### Reference Stores
1. **Hash References** (`refs/by-hash/`)
   - Maps hash → list of cache IDs
   - Tracks latest_id and total_versions
   - Sharded path: `aa/bb/{hash}.json`

2. **ID References** (`refs/by-id/`)
   - Maps cache ID → hash and metadata
   - Stores all file paths and strategy info
   - Sharded path: `aa/bb/{cache_id}.json`

#### Data Storage
- Location depends on strategy
- Files stored as `.json` or `.binary` based on content type
- Metadata stored in `.metadata` files

## Response Schemas

### Store Response (`Schema__Cache__Store__Response`)
```json
{
  "cache_id": "uuid-format",
  "hash": "16-char-hash",
  "namespace": "production",
  "paths": {
    "data": ["path/to/data/files"],
    "by_hash": ["refs/by-hash/paths"],
    "by_id": ["refs/by-id/paths"]
  },
  "size": 12345
}
```

### Retrieve Response (with metadata)
```json
{
  "data": "<content>",
  "metadata": {
    "cache_hash": "hash",
    "cache_id": "uuid",
    "cache_key": "original-key",
    "stored_at": "timestamp",
    "strategy": "temporal_latest",
    "namespace": "default",
    "file_type": "json|binary|string",
    "content_encoding": "gzip"
  },
  "data_type": "json|binary|string"
}
```

### Stats Response
```json
{
  "namespace": "default",
  "s3_bucket": "mgraph-ai-cache",
  "s3_prefix": "namespace-name",
  "ttl_hours": 24,
  "direct_files": 0,
  "temporal_files": 10,
  "temporal_latest_files": 5,
  "temporal_versioned_files": 15,
  "refs_hash_files": 20,
  "refs_id_files": 30,
  "total_files": 80
}
```

## Implementation Details

### Hash Generation (`Cache__Hash__Generator`)
- Consistent hashing across data types
- JSON: Sorted keys for deterministic hashing
- Strings: UTF-8 encoded before hashing
- Binary: Direct hash calculation
- Type_Safe objects: Converted to JSON first

### Compression Support (in some store methods)
- Auto-detects `Content-Encoding: gzip`
- Decompresses for hash calculation
- Stores compressed version for efficiency
- Transparent decompression on retrieval

### Namespace Management
- Dynamic namespace creation
- Default namespace: "default"
- Each namespace has isolated:
  - S3 prefix
  - TTL settings (default: 24 hours)
  - Storage handlers

## AWS Lambda Deployment

### Configuration
- Handler: `mgraph_ai_service_cache.fast_api.lambda_handler.run`
- Dependencies loaded via `boto3__lambda.load_dependencies()`
- Environment detection via `AWS_REGION` variable

### Dependencies
```python
LAMBDA_DEPENDENCIES__FAST_API_SERVERLESS = [
    'osbot-fast-api-serverless==v1.19.0',
    'memory-fs==v0.24.0'
]
```

### Deployment Class
- `Deploy__Service` extends `Deploy__Serverless__Fast_API`
- Service name: `mgraph_ai_service_cache`
- Supports environment variable configuration

## Best Practices

### Content Type Selection
- **String**: Plain text, logs, simple values
- **JSON**: Structured data, API responses
- **Binary**: Files, compressed data, images

### Strategy Selection
- **High read, rare update**: Use `temporal_latest`
- **Audit requirements**: Use `temporal_versioned`
- **Simple caching**: Use `direct`
- **Time-series data**: Use `temporal`
- **Organized structure**: Use `semantic_file` with meaningful paths

### Performance Optimization
- Hash sharding distributes S3 load
- Compression reduces storage and transfer
- Reference stores enable fast lookups
- Namespace isolation prevents cross-contamination

### Error Handling
- Returns 404 for missing content
- Graceful handling of compression errors
- Type conversion attempts for format mismatches
- Partial deletion tracking in delete operations

## Security Considerations

### S3 Permissions Required
- `s3:GetObject`
- `s3:PutObject`
- `s3:DeleteObject`
- `s3:ListBucket`
- `s3:GetObjectMetadata`
- `s3:PutObjectMetadata`

### Data Isolation
- Complete namespace isolation
- No cross-namespace retrieval
- Separate S3 prefixes per namespace

## Version Information
- Current version: v0.5.30
- Python package: `mgraph_ai_service_cache`
- FastAPI framework with OpenAPI 3.1.0
- AWS Lambda runtime compatible

## Integration Examples

### Python Client Example
```python
import requests
import json

class CacheClient:
    def __init__(self, base_url="https://cache.dev.mgraph.ai"):
        self.base_url = base_url
    
    def store_json(self, data, strategy="temporal_latest", namespace="default"):
        response = requests.post(
            f"{self.base_url}/{namespace}/{strategy}/store/json",
            json=data
        )
        return response.json()
    
    def store_semantic_json(self, data, path, namespace="default", file_id=None):
        """Store JSON with semantic path (NEW in v0.5.30)"""
        url = f"{self.base_url}/{namespace}/semantic_file/store/json/{path}"
        params = {"file_id": file_id} if file_id else {}
        response = requests.post(url, json=data, params=params)
        return response.json()
    
    def retrieve_by_hash(self, cache_hash, namespace="default"):
        response = requests.get(
            f"{self.base_url}/{namespace}/retrieve/hash/{cache_hash}"
        )
        return response.json()
    
    def delete_by_id(self, cache_id, namespace="default"):
        response = requests.delete(
            f"{self.base_url}/{namespace}/delete/{cache_id}"
        )
        return response.json()
```

### Semantic File Organization Example (NEW)
```python
# Organize cache by date and category
def cache_daily_report(client, date, category, report_data):
    path = f"reports/{date.year}/{date.month:02d}/{date.day:02d}/{category}"
    file_id = f"{category}-{date.isoformat()}"
    
    return client.store_semantic_json(
        data=report_data,
        path=path,
        namespace="analytics",
        file_id=file_id
    )

# Result: Creates file at:
# data/semantic-file/reports/2025/01/16/sales/sales-2025-01-16.json
```

### Handling Binary Data with Compression
```python
import gzip
import requests

def cache_compressed_file(file_path, namespace="files"):
    with open(file_path, 'rb') as f:
        content = f.read()
    
    # Compress before sending
    compressed = gzip.compress(content)
    
    response = requests.post(
        f"https://cache.dev.mgraph.ai/{namespace}/temporal_versioned/store/binary",
        data=compressed,
        headers={"Content-Encoding": "gzip"}
    )
    
    return response.json()
```