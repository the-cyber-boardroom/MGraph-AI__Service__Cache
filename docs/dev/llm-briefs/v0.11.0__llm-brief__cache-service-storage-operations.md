# Cache Service Storage Operations - LLM Technical Brief

**Version**: v1.4.45  
**Date**: January 2026  
**Service**: mgraph-ai-service-cache  
**Related**: Html_Cache__Client, FLeT Architecture v1.4.44

---

## Executive Summary

This document provides a comprehensive technical reference for understanding how the MGraph Cache Service stores, indexes, and retrieves data. The cache service implements a **two-tier storage model** that separates entity management (Tier 1) from data storage (Tier 2), enabling efficient deduplication, fast lookups, and flexible data organization.

**Key Concepts:**
- **Tier 1 (Entry Storage)**: Creates the entity "anchor" with identity, metadata, and reference files
- **Tier 2 (Data Storage)**: Stores actual content (HTML, graphs, etc.) within the entity's data folder
- **Hash-based Deduplication**: Uses `cache_hash` derived from `cache_key` to prevent duplicate entries
- **Dual Reference System**: Maintains both `by-hash` and `by-id` indexes for O(1) lookups

---

## Table of Contents

1. [Introduction](#1-introduction)
2. [High-Level Architecture](#2-high-level-architecture)
3. [Two-Tier Storage Model](#3-two-tier-storage-model)
4. [Storage Sequence - Step by Step](#4-storage-sequence---step-by-step)
5. [File Structure Deep Dive](#5-file-structure-deep-dive)
6. [Hash Calculations](#6-hash-calculations)
7. [Reference Files (Indexes)](#7-reference-files-indexes)
8. [Metadata System](#8-metadata-system)
9. [Data Layer Operations (Tier 2)](#9-data-layer-operations-tier-2)
10. [Code Reference](#10-code-reference)
11. [Troubleshooting Guide](#11-troubleshooting-guide)

---

## 1. Introduction

### 1.1 The Problem

When building systems that process web content (HTML pages, transformed graphs, extracted data), several challenges emerge:

1. **Deduplication**: How do we avoid storing the same URL's content multiple times?
2. **Identity**: How do we uniquely identify a cached entry?
3. **Lookup Speed**: How do we quickly check "do we already have this?"
4. **Data Organization**: How do we store multiple related outputs (raw HTML, cleaned HTML, graph, metadata) for a single URL?
5. **Auditability**: How do we track when content was stored and whether it changed?

### 1.2 The Solution

The Cache Service solves these problems through:

| Problem | Solution |
|---------|----------|
| Deduplication | Hash the `cache_key` (typically URL) to create `cache_hash` |
| Identity | Generate unique `cache_id` (GUID) per entry |
| Lookup Speed | Maintain `by-hash` and `by-id` reference files |
| Data Organization | Two-tier model: entry anchor (Tier 1) + data folder (Tier 2) |
| Auditability | Metadata files with timestamps, content hashes, version chains |

### 1.3 Key Terminology

| Term | Definition | Example |
|------|------------|---------|
| `namespace` | Logical partition for entries | `'html-graph-service'` |
| `cache_key` | Semantic identifier (usually URL or path) | `'https://example.com/page'` |
| `cache_hash` | Hash of cache_key for deduplication | `'3fe62295e631cace'` |
| `cache_id` | Unique GUID for this entry | `'a1b2c3d4-e5f6-...'` |
| `file_id` | Name of the entry file | `'root'` |
| `data_key` | Path within data folder | `'html'`, `'html/processed'` |
| `data_file_id` | Filename within data_key folder | `'raw'`, `'cleaned'` |
| `content_hash` | Hash of actual stored content | `'8cdcee46a5'` |

### 1.4 When to Use This Document

Use this document when you need to:
- Understand why certain files exist in the cache storage
- Debug cache lookup failures
- Implement new cache operations
- Understand the relationship between cache_key, cache_hash, and cache_id
- Trace the complete storage flow from API call to files on disk

---

## 2. High-Level Architecture

### 2.1 System Overview

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              CLIENT LAYER                                            │
│  ┌─────────────────────┐    ┌─────────────────────┐    ┌─────────────────────┐     │
│  │  Html_Cache__Client │    │   FLeT__Html__To__  │    │  FLeT__Html__From__ │     │
│  │                     │    │        Cache        │    │        Cache        │     │
│  │  - entry__store()   │    │  - execute()        │    │  - execute()        │     │
│  │  - entry__retrieve()│    │                     │    │                     │     │
│  │  - data__store_*()  │    │  Uses Tier 2 ops    │    │  Uses Tier 2 ops    │     │
│  │  - data__retrieve_*()│   └─────────────────────┘    └─────────────────────┘     │
│  └──────────┬──────────┘                                                            │
└─────────────┼───────────────────────────────────────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              API LAYER (FastAPI)                                     │
│  ┌─────────────────────┐    ┌─────────────────────┐    ┌─────────────────────┐     │
│  │  Routes__File__Store│    │Routes__File__Retrieve│   │  Routes__File__Data │     │
│  │                     │    │                     │    │                     │     │
│  │  POST /store/json/  │    │  GET /retrieve/     │    │  POST /data/store/  │     │
│  │       {cache_key}   │    │      {cache_id}     │    │       {cache_id}    │     │
│  └──────────┬──────────┘    └──────────┬──────────┘    └──────────┬──────────┘     │
└─────────────┼───────────────────────────┼───────────────────────────┼───────────────┘
              │                           │                           │
              ▼                           ▼                           ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              SERVICE LAYER                                           │
│  ┌─────────────────────┐    ┌─────────────────────┐    ┌─────────────────────┐     │
│  │ Cache__Service__Store│   │    Cache__Service   │    │Cache__Service__Data │     │
│  │                     │    │                     │    │                     │     │
│  │  - store_json()     │    │  - store_with_      │    │  - store_string()   │     │
│  │  - store_string()   │    │      strategy()     │    │  - retrieve_string()│     │
│  └──────────┬──────────┘    └──────────┬──────────┘    └──────────┬──────────┘     │
└─────────────┼───────────────────────────┼───────────────────────────┼───────────────┘
              │                           │                           │
              ▼                           ▼                           ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              STORAGE LAYER                                           │
│  ┌─────────────────────────────────────────────────────────────────────────────┐   │
│  │                    Cache__Service__Store__With_Strategy                      │   │
│  │                                                                              │   │
│  │   execute(context):                                                          │   │
│  │     1. initialize_context()     ─── Set defaults, generate cache_id         │   │
│  │     2. store_data()             ─── Write entry file + config + metadata    │   │
│  │     3. update_hash_reference()  ─── Create/update by-hash index             │   │
│  │     4. create_file_refs()       ─── Create by-id index                      │   │
│  │     5. build_response()         ─── Return cache_id + status                │   │
│  └─────────────────────────────────────────────────────────────────────────────┘   │
│                                        │                                            │
│                                        ▼                                            │
│  ┌─────────────────────────────────────────────────────────────────────────────┐   │
│  │                         FILE SYSTEM / S3                                     │   │
│  │                                                                              │   │
│  │   {namespace}/                                                               │   │
│  │   ├── data/key-based/{cache_key}/                                           │   │
│  │   │   ├── {file_id}.json                    ← Entry content                 │   │
│  │   │   ├── {file_id}.json.config             ← Entry config                  │   │
│  │   │   ├── {file_id}.json.metadata           ← Entry metadata                │   │
│  │   │   └── {file_id}/data/                   ← Tier 2 data folder            │   │
│  │   │       └── {data_key}/{data_file_id}.*   ← Actual content                │   │
│  │   └── refs/                                                                  │   │
│  │       ├── by-hash/{aa}/{bb}/{cache_hash}.json  ← Hash index                 │   │
│  │       └── by-id/{xx}/{yy}/{cache_id}.json      ← ID index                   │   │
│  └─────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Request Flow Diagram

```
┌──────────────┐         ┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│    Client    │         │   FastAPI    │         │   Service    │         │  File System │
│              │         │   Routes     │         │    Layer     │         │              │
└──────┬───────┘         └──────┬───────┘         └──────┬───────┘         └──────┬───────┘
       │                        │                        │                        │
       │  entry__store()        │                        │                        │
       │───────────────────────>│                        │                        │
       │                        │                        │                        │
       │                        │  store_json()          │                        │
       │                        │───────────────────────>│                        │
       │                        │                        │                        │
       │                        │                        │  1. Calculate cache_hash
       │                        │                        │─────────────────┐      │
       │                        │                        │<────────────────┘      │
       │                        │                        │                        │
       │                        │                        │  2. Generate cache_id  │
       │                        │                        │─────────────────┐      │
       │                        │                        │<────────────────┘      │
       │                        │                        │                        │
       │                        │                        │  3. Write entry.json   │
       │                        │                        │───────────────────────>│
       │                        │                        │                        │
       │                        │                        │  4. Write .config      │
       │                        │                        │───────────────────────>│
       │                        │                        │                        │
       │                        │                        │  5. Write .metadata    │
       │                        │                        │───────────────────────>│
       │                        │                        │                        │
       │                        │                        │  6. Write by-hash ref  │
       │                        │                        │───────────────────────>│
       │                        │                        │                        │
       │                        │                        │  7. Write by-id ref    │
       │                        │                        │───────────────────────>│
       │                        │                        │                        │
       │                        │  {cache_id, status}    │                        │
       │                        │<───────────────────────│                        │
       │                        │                        │                        │
       │  {cache_id, status}    │                        │                        │
       │<───────────────────────│                        │                        │
       │                        │                        │                        │
```

---

## 3. Two-Tier Storage Model

### 3.1 Conceptual Model

The cache service separates storage into two distinct tiers:

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────┐    │
│  │                         TIER 1: ENTRY STORAGE                               │    │
│  │                                                                             │    │
│  │   Purpose: Establish entity identity and enable lookups                     │    │
│  │                                                                             │    │
│  │   ┌─────────────┐   ┌─────────────────┐   ┌──────────────────┐            │    │
│  │   │ entry.json  │   │ entry.json      │   │ entry.json       │            │    │
│  │   │             │   │    .config      │   │    .metadata     │            │    │
│  │   │ {cache_key} │   │ {settings}      │   │ {content_hash,   │            │    │
│  │   │             │   │                 │   │  timestamp, ...} │            │    │
│  │   └─────────────┘   └─────────────────┘   └──────────────────┘            │    │
│  │                                                                             │    │
│  │   Identity Resolution:                                                      │    │
│  │   cache_key ──hash──> cache_hash ──lookup──> cache_id ──lookup──> files    │    │
│  │                                                                             │    │
│  │   Created by: entry__store() / Html_Cache__Client.entry__store()           │    │
│  └────────────────────────────────────────────────────────────────────────────┘    │
│                                         │                                           │
│                                         │ contains reference to                     │
│                                         ▼                                           │
│  ┌────────────────────────────────────────────────────────────────────────────┐    │
│  │                         TIER 2: DATA STORAGE                                │    │
│  │                                                                             │    │
│  │   Purpose: Store actual content within the established entity               │    │
│  │                                                                             │    │
│  │   {file_id}/data/                                                           │    │
│  │   ├── html/                          ← data_key = 'html'                   │    │
│  │   │   ├── raw.txt                    ← data_file_id = 'raw'                │    │
│  │   │   └── cleaned.txt                ← data_file_id = 'cleaned'            │    │
│  │   ├── graph/                         ← data_key = 'graph'                  │    │
│  │   │   └── mgraph.json                ← data_file_id = 'mgraph'             │    │
│  │   └── analysis/                      ← data_key = 'analysis'               │    │
│  │       └── stats.json                 ← data_file_id = 'stats'              │    │
│  │                                                                             │    │
│  │   Created by: data__store_*() / FLeT__Html__To__Cache.execute()            │    │
│  └────────────────────────────────────────────────────────────────────────────┘    │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Why Two Tiers?

| Aspect | Single-Tier Problem | Two-Tier Solution |
|--------|---------------------|-------------------|
| Entry Size | Large entries slow down metadata operations | Entry stays small (~32 bytes) |
| Multiple Outputs | Must update entire entry for each new output | Add files to data folder without touching entry |
| Atomic Identity | Content changes = new identity? | Identity fixed at creation; content can evolve |
| Lookup Speed | Must read large file to check existence | Read small entry or just check refs |
| Versioning | Complex to track what changed | Entry metadata vs data folder contents |

### 3.3 Tier Responsibilities

```
┌─────────────────────────────────────┬─────────────────────────────────────┐
│           TIER 1                    │           TIER 2                    │
│      (Entry Storage)                │       (Data Storage)                │
├─────────────────────────────────────┼─────────────────────────────────────┤
│                                     │                                     │
│  ✓ Establish entity identity        │  ✓ Store actual content             │
│  ✓ Enable deduplication             │  ✓ Multiple data types per entity   │
│  ✓ Provide fast lookups             │  ✓ Flexible folder structure        │
│  ✓ Track creation metadata          │  ✓ Independent updates              │
│  ✓ Support hash-based existence     │  ✓ Large content (HTML, graphs)     │
│    checks                           │                                     │
│                                     │                                     │
│  Created ONCE per cache_key         │  Created MANY times per entity      │
│                                     │                                     │
│  Operation: entry__store()          │  Operation: data__store_*()         │
│                                     │                                     │
└─────────────────────────────────────┴─────────────────────────────────────┘
```

---

## 4. Storage Sequence - Step by Step

### 4.1 Complete Storage Flow

When `Html_Cache__Client.entry__store()` is called, here is the complete sequence:

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│  STEP 1: Client Prepares Entry                                                       │
│                                                                                      │
│  entry = Schema__Html_Cache__Entry()                                                │
│  entry.cache_key = 'test/entity'        ← Set the semantic key                      │
│                                                                                      │
│  Input State:                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────────┐   │
│  │  namespace       = 'test-html-to-cache'                                      │   │
│  │  cache_key       = 'test/entity'                                             │   │
│  │  file_id         = 'root'                                                    │   │
│  │  json_field_path = 'cache_key'        ← Hash THIS field for identity        │   │
│  │  entry           = {'cache_key': 'test/entity'}                              │   │
│  └─────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│  STEP 2: Calculate cache_hash                                                        │
│                                                                                      │
│  Location: Cache__Service__Store.store_json()                                       │
│                                                                                      │
│  if json_field_path:                                                                │
│      cache_hash = hash_from_json_field(data, 'cache_key')                           │
│                                                                                      │
│  Calculation:                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────────┐   │
│  │  1. Extract field value: data['cache_key'] = 'test/entity'                   │   │
│  │  2. Convert to string:   'test/entity'                                       │   │
│  │  3. Apply hash function: hashlib.blake2b('test/entity'.encode(), ...)        │   │
│  │  4. Truncate to 16 chars: '3fe62295e631cace'                                 │   │
│  │                                                                              │   │
│  │  Result: cache_hash = '3fe62295e631cace'                                     │   │
│  └─────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│  STEP 3: Generate cache_id and Build Context                                         │
│                                                                                      │
│  Location: Cache__Service.store_with_strategy()                                     │
│                                                                                      │
│  cache_id = Cache_Id(Random_Guid())     ← e.g., 'a1b2c3d4-e5f6-7890-abcd-...'      │
│                                                                                      │
│  context = Schema__Store__Context(                                                  │
│      storage_data    = {'cache_key': 'test/entity'},                                │
│      cache_hash      = '3fe62295e631cace',                                          │
│      cache_id        = 'a1b2c3d4-...',                                              │
│      cache_key       = 'test/entity',                                               │
│      file_id         = 'root',                                                      │
│      json_field_path = 'cache_key',                                                 │
│      namespace       = 'test-html-to-cache',                                        │
│      strategy        = 'key_based',                                                 │
│      handler         = <namespace_handler>,                                         │
│  )                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│  STEP 4: Execute Storage Strategy                                                    │
│                                                                                      │
│  Location: Cache__Service__Store__With_Strategy.execute()                           │
│                                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────────┐   │
│  │                                                                              │   │
│  │  4a. initialize_context(context)                                             │   │
│  │      - Set defaults for missing fields                                       │   │
│  │      - Initialize tracking structures                                        │   │
│  │                                                                              │   │
│  │  4b. store_data(context)                                                     │   │
│  │      - Write {file_id}.json         (the entry content)                      │   │
│  │      - Write {file_id}.json.config  (storage configuration)                  │   │
│  │      - Write {file_id}.json.metadata (content hash, timestamps)              │   │
│  │                                                                              │   │
│  │  4c. update_hash_reference(context)                                          │   │
│  │      - Write refs/by-hash/{aa}/{bb}/{cache_hash}.json                        │   │
│  │      - Maps: cache_hash → file location                                      │   │
│  │                                                                              │   │
│  │  4d. create_file_refs(context)                                               │   │
│  │      - Write refs/by-id/{xx}/{yy}/{cache_id}.json                            │   │
│  │      - Maps: cache_id → file location + metadata                             │   │
│  │                                                                              │   │
│  │  4e. build_response(context)                                                 │   │
│  │      - Return Schema__Cache__Store__Response with cache_id                   │   │
│  │                                                                              │   │
│  └─────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│  STEP 5: Files Created on Disk                                                       │
│                                                                                      │
│  test-html-to-cache/                                                                │
│  ├── data/                                                                          │
│  │   └── key-based/                                                                 │
│  │       └── test/                                                                  │
│  │           └── entity/                          ← cache_key path                  │
│  │               ├── root.json                    ← Entry content                   │
│  │               ├── root.json.config             ← Config                          │
│  │               ├── root.json.metadata           ← Metadata                        │
│  │               └── root/                                                          │
│  │                   └── data/                    ← TIER 2 DATA FOLDER              │
│  │                       └── (empty, ready for FLeT data)                           │
│  └── refs/                                                                          │
│      ├── by-hash/                                                                   │
│      │   └── 3f/                                  ← First 2 chars                   │
│      │       └── e6/                              ← Next 2 chars                    │
│      │           └── 3fe62295e631cace.json        ← Hash reference                  │
│      └── by-id/                                                                     │
│          └── a1/                                  ← First 2 chars of cache_id       │
│              └── b2/                              ← Next 2 chars                    │
│                  └── a1b2c3d4-....json            ← ID reference                    │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Timing Diagram

```
Time ──────────────────────────────────────────────────────────────────────────────────>

     │ entry__store() │
     │                │
     ├────────────────┤
     │  Calculate     │
     │  cache_hash    │ ~0.1ms (in-memory hash)
     ├────────────────┤
     │  Generate      │
     │  cache_id      │ ~0.1ms (UUID generation)
     ├────────────────┤
     │  Write         │
     │  entry.json    │ ~1-5ms (file I/O)
     ├────────────────┤
     │  Write         │
     │  .config       │ ~1-5ms (file I/O)
     ├────────────────┤
     │  Write         │
     │  .metadata     │ ~1-5ms (file I/O)
     ├────────────────┤
     │  Write         │
     │  by-hash ref   │ ~1-5ms (file I/O)
     ├────────────────┤
     │  Write         │
     │  by-id ref     │ ~1-5ms (file I/O)
     ├────────────────┤
     │  Return        │
     │  response      │
     │                │
     └────────────────┘

     Total: ~5-25ms for entry creation (varies by storage backend)
```

---

## 5. File Structure Deep Dive

### 5.1 Complete File Tree

For an entry with:
- `namespace = 'test-html-to-cache'`
- `cache_key = 'test/entity'`
- `file_id = 'root'`
- `cache_hash = '3fe62295e631cace'`
- `cache_id = 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'`

```
test-html-to-cache/                                  ← NAMESPACE ROOT
│
├── data/                                            ← DATA STORAGE AREA
│   └── key-based/                                   ← STRATEGY FOLDER
│       └── test/                                    ← cache_key path segment 1
│           └── entity/                              ← cache_key path segment 2
│               │
│               │  ┌─────────────────────────────────────────────────────────┐
│               │  │              TIER 1: ENTRY FILES                        │
│               │  └─────────────────────────────────────────────────────────┘
│               │
│               ├── root.json                        ← Entry content
│               │   {
│               │     "cache_key": "test/entity"
│               │   }
│               │
│               ├── root.json.config                 ← Storage config
│               │   {
│               │     "file_type": "json",
│               │     "strategy": "key_based",
│               │     ...
│               │   }
│               │
│               ├── root.json.metadata               ← Content metadata
│               │   {
│               │     "content__hash": "8cdcee46a5",
│               │     "content__size": 32,
│               │     "timestamp": "2026-01-17T...",
│               │     ...
│               │   }
│               │
│               │  ┌─────────────────────────────────────────────────────────┐
│               │  │              TIER 2: DATA FOLDER                        │
│               │  └─────────────────────────────────────────────────────────┘
│               │
│               └── root/                            ← file_id folder
│                   └── data/                        ← Data storage root
│                       │
│                       ├── html/                    ← data_key
│                       │   ├── raw.txt              ← data_file_id (FLeT stores HTML here)
│                       │   └── cleaned.txt          ← Another data_file_id
│                       │
│                       ├── graph/                   ← Another data_key
│                       │   └── mgraph.json          ← MGraph output
│                       │
│                       └── metadata/                ← Another data_key
│                           └── stats.json           ← Analysis output
│
└── refs/                                            ← REFERENCE INDEX AREA
    │
    │  ┌─────────────────────────────────────────────────────────────────────┐
    │  │              HASH INDEX (for deduplication checks)                  │
    │  └─────────────────────────────────────────────────────────────────────┘
    │
    ├── by-hash/
    │   └── 3f/                                      ← cache_hash[0:2]
    │       └── e6/                                  ← cache_hash[2:4]
    │           └── 3fe62295e631cace.json            ← Full cache_hash
    │               {
    │                 "cache_id": "a1b2c3d4-...",
    │                 "file_path": "data/key-based/test/entity/root.json",
    │                 ...
    │               }
    │
    │  ┌─────────────────────────────────────────────────────────────────────┐
    │  │              ID INDEX (for direct retrieval)                        │
    │  └─────────────────────────────────────────────────────────────────────┘
    │
    └── by-id/
        └── a1/                                      ← cache_id[0:2]
            └── b2/                                  ← cache_id[2:4]
                └── a1b2c3d4-e5f6-7890-abcd-ef1234567890.json
                    {
                      "cache_hash": "3fe62295e631cace",
                      "file_path": "data/key-based/test/entity/root.json",
                      "all_paths": [...],
                      ...
                    }
```

### 5.2 File Contents Detail

#### 5.2.1 Entry File (`root.json`)

```json
{
  "cache_key": "test/entity"
}
```

This is the actual entry data. The `cache_key` field is used because `json_field_path = 'cache_key'` was specified.

#### 5.2.2 Config File (`root.json.config`)

```json
{
  "file_type": "json",
  "strategy": "key_based",
  "namespace": "test-html-to-cache",
  "cache_key": "test/entity",
  "file_id": "root"
}
```

Contains storage configuration and strategy used.

#### 5.2.3 Metadata File (`root.json.metadata`)

```json
{
  "content__hash": "8cdcee46a5",
  "content__size": 32,
  "timestamp": "2026-01-17T12:34:56.789Z",
  "chain_hash": null,
  "previous_version_path": null,
  "tags": [],
  "data": {
    "cache_hash": "3fe62295e631cace",
    "cache_key": "test/entity",
    "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "content_encoding": null,
    "file_id": "root",
    "file_type": "json",
    "json_field_path": "cache_key",
    "namespace": "test-html-to-cache",
    "stored_at": "2026-01-17T12:34:56.789Z",
    "strategy": "key_based"
  }
}
```

**Key fields:**
- `content__hash`: Hash of the actual content (for detecting changes)
- `content__size`: Size in bytes
- `data.cache_hash`: The identity hash (from cache_key)
- `data.json_field_path`: Which field was used for hashing

#### 5.2.4 By-Hash Reference (`3fe62295e631cace.json`)

```json
{
  "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "cache_hash": "3fe62295e631cace",
  "namespace": "test-html-to-cache",
  "file_path": "data/key-based/test/entity/root.json",
  "strategy": "key_based",
  "timestamp": "2026-01-17T12:34:56.789Z"
}
```

**Purpose**: Given a `cache_hash`, find the `cache_id` and file location.

#### 5.2.5 By-ID Reference (`a1b2c3d4-....json`)

```json
{
  "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "cache_hash": "3fe62295e631cace",
  "namespace": "test-html-to-cache",
  "strategy": "key_based",
  "file_type": "json",
  "timestamp": "2026-01-17T12:34:56.789Z",
  "all_paths": {
    "data": [
      "data/key-based/test/entity/root.json",
      "data/key-based/test/entity/root.json.config",
      "data/key-based/test/entity/root.json.metadata"
    ],
    "by_hash": ["refs/by-hash/3f/e6/3fe62295e631cace.json"],
    "by_id": ["refs/by-id/a1/b2/a1b2c3d4-....json"]
  },
  "file_paths": {
    "content_files": ["data/key-based/test/entity/root.json"],
    "data_folders": ["data/key-based/test/entity/root/data"]
  }
}
```

**Purpose**: Given a `cache_id`, find all associated files and the data folder.

---

## 6. Hash Calculations

### 6.1 Two Types of Hashes

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                      │
│   ┌─────────────────────────────────┐    ┌─────────────────────────────────┐       │
│   │         cache_hash              │    │        content_hash             │       │
│   │                                 │    │                                 │       │
│   │   Purpose: IDENTITY             │    │   Purpose: INTEGRITY            │       │
│   │                                 │    │                                 │       │
│   │   Input: cache_key value        │    │   Input: Actual file content    │       │
│   │   (e.g., 'test/entity')         │    │   (e.g., the JSON bytes)        │       │
│   │                                 │    │                                 │       │
│   │   Used for:                     │    │   Used for:                     │       │
│   │   - Deduplication               │    │   - Change detection            │       │
│   │   - "Do we have this URL?"      │    │   - "Did content change?"       │       │
│   │                                 │    │                                 │       │
│   │   Calculated: ONCE at creation  │    │   Calculated: Each write        │       │
│   │                                 │    │                                 │       │
│   │   Length: 16 characters         │    │   Length: 10 characters         │       │
│   │   Example: '3fe62295e631cace'   │    │   Example: '8cdcee46a5'         │       │
│   │                                 │    │                                 │       │
│   └─────────────────────────────────┘    └─────────────────────────────────┘       │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 cache_hash Calculation

```python
# In Cache__Hash__Generator

def from_string(self, value: str) -> Safe_Str__Cache_Hash:
    """Hash a string value to create cache_hash."""
    
    # 1. Encode string to bytes
    value_bytes = value.encode('utf-8')          # 'test/entity' → b'test/entity'
    
    # 2. Apply BLAKE2b hash (fast, cryptographic)
    hash_obj = hashlib.blake2b(value_bytes, digest_size=8)
    
    # 3. Convert to hex string
    hash_hex = hash_obj.hexdigest()              # '3fe62295e631cace'
    
    return Safe_Str__Cache_Hash(hash_hex)

# Example:
# from_string('test/entity') → '3fe62295e631cace'
# from_string('https://example.com/page') → 'a7f3b2c1d4e5f678'
```

### 6.3 content_hash Calculation

```python
# In safe_str_hash function

def safe_str_hash(content_bytes: bytes) -> str:
    """Hash content bytes for integrity checking."""
    
    # 1. Apply SHA-256 hash
    hash_obj = hashlib.sha256(content_bytes)
    
    # 2. Get hex digest and truncate to 10 chars
    hash_hex = hash_obj.hexdigest()[:10]         # '8cdcee46a5'
    
    return hash_hex

# Example for entry content:
# content_str = '{\n  "cache_key": "test/entity"\n}'
# content_bytes = content_str.encode()  # 32 bytes
# content_hash = safe_str_hash(content_bytes)  # '8cdcee46a5'
```

### 6.4 Hash Sharding for References

Both `by-hash` and `by-id` references use **2-level sharding** to avoid directory bloat:

```
cache_hash = '3fe62295e631cace'
              ││││
              ││││
              ││└┴─────────────────────────── Filename: 3fe62295e631cace.json
              │└───────────────────────────── Level 2 dir: e6/
              └────────────────────────────── Level 1 dir: 3f/

Path: refs/by-hash/3f/e6/3fe62295e631cace.json

cache_id = 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'
            ││││
            ││││
            ││└┴───────────────────────────── Filename: a1b2c3d4-....json
            │└─────────────────────────────── Level 2 dir: b2/
            └──────────────────────────────── Level 1 dir: a1/

Path: refs/by-id/a1/b2/a1b2c3d4-e5f6-7890-abcd-ef1234567890.json
```

**Why sharding?**
- Without sharding: 1 million entries = 1 million files in one directory
- With 2-level sharding: ~4000 files per directory maximum (256 × 256 combinations)

---

## 7. Reference Files (Indexes)

### 7.1 Lookup Patterns

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         LOOKUP PATTERN 1: By Hash                                    │
│                                                                                      │
│  Use case: "Do we already have this URL cached?"                                    │
│                                                                                      │
│  ┌──────────┐      ┌──────────┐      ┌──────────┐      ┌──────────┐               │
│  │  URL or  │──────│ Calculate│──────│  Look up │──────│  Found?  │               │
│  │cache_key │      │cache_hash│      │ by-hash  │      │cache_id  │               │
│  └──────────┘      └──────────┘      │   ref    │      └──────────┘               │
│                                      └──────────┘                                   │
│                                                                                      │
│  Code:                                                                              │
│    cache_hash = hash_generator.from_string(cache_key)                               │
│    exists = cache_client.entry__exists_by_hash(namespace, cache_hash)               │
│                                                                                      │
│  File accessed: refs/by-hash/{aa}/{bb}/{cache_hash}.json                            │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         LOOKUP PATTERN 2: By ID                                      │
│                                                                                      │
│  Use case: "Retrieve the entry with this cache_id"                                  │
│                                                                                      │
│  ┌──────────┐      ┌──────────┐      ┌──────────┐      ┌──────────┐               │
│  │ cache_id │──────│  Look up │──────│   Get    │──────│  Read    │               │
│  │          │      │  by-id   │      │file_path │      │  entry   │               │
│  └──────────┘      │   ref    │      └──────────┘      └──────────┘               │
│                    └──────────┘                                                     │
│                                                                                      │
│  Code:                                                                              │
│    entry_data = cache_client.entry__retrieve(namespace, cache_id)                   │
│                                                                                      │
│  Files accessed:                                                                    │
│    1. refs/by-id/{xx}/{yy}/{cache_id}.json  (get file path)                         │
│    2. data/key-based/{cache_key}/{file_id}.json  (read content)                     │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         LOOKUP PATTERN 3: By Key                                     │
│                                                                                      │
│  Use case: "Get cache_id for this cache_key"                                        │
│                                                                                      │
│  ┌──────────┐      ┌──────────┐      ┌──────────┐      ┌──────────┐               │
│  │cache_key │──────│ Calculate│──────│  Look up │──────│  Extract │               │
│  │          │      │cache_hash│      │ by-hash  │      │ cache_id │               │
│  └──────────┘      └──────────┘      │   ref    │      └──────────┘               │
│                                      └──────────┘                                   │
│                                                                                      │
│  Code:                                                                              │
│    cache_id = cache_client.cache_id__from_key(namespace, cache_key)                 │
│                                                                                      │
│  Internally:                                                                        │
│    cache_hash = hash_generator.from_string(cache_key)                               │
│    ref = read(refs/by-hash/{cache_hash}.json)                                       │
│    return ref['cache_id']                                                           │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 7.2 Reference File Schemas

```python
# By-Hash Reference (Schema__Cache__Hash__Reference)
class Schema__Cache__Hash__Reference(Type_Safe):
    cache_id   : Cache_Id                    # The entry's unique ID
    cache_hash : Safe_Str__Cache_Hash        # The hash (filename without .json)
    namespace  : Safe_Str__Namespace         # Namespace
    file_path  : str                         # Path to entry file
    strategy   : str                         # 'key_based', 'hash_based', etc.
    timestamp  : str                         # Creation timestamp

# By-ID Reference (Schema__Cache__File__Refs)
class Schema__Cache__File__Refs(Type_Safe):
    cache_id   : Cache_Id                    # The entry's unique ID
    cache_hash : Safe_Str__Cache_Hash        # For reverse lookup
    namespace  : Safe_Str__Namespace         # Namespace
    strategy   : str                         # Storage strategy
    file_type  : str                         # 'json', 'string', 'binary'
    timestamp  : str                         # Creation timestamp
    all_paths  : Schema__All_Paths           # All file paths
    file_paths : Schema__File_Paths          # Content and data paths
```

---

## 8. Metadata System

### 8.1 Metadata Schema

```python
class Schema__Cache__File__Metadata(Type_Safe):
    content__hash          : str             # Hash of actual content (integrity)
    content__size          : int             # Size in bytes
    timestamp              : str             # When metadata was written
    chain_hash             : str = None      # For version chaining
    previous_version_path  : str = None      # Previous version (if updated)
    tags                   : List[str] = []  # User-defined tags
    data                   : Schema__Cache__Store__Metadata  # Detailed metadata

class Schema__Cache__Store__Metadata(Type_Safe):
    cache_hash       : Safe_Str__Cache_Hash        # Identity hash
    cache_key        : Safe_Str__Cache_Key         # Original key
    cache_id         : Cache_Id                    # Entry ID
    content_encoding : str = None                  # e.g., 'gzip'
    file_id          : str                         # Entry file name
    file_type        : str                         # 'json', 'string'
    json_field_path  : str                         # Field used for hashing
    namespace        : str                         # Namespace
    stored_at        : str                         # Timestamp
    strategy         : str                         # Storage strategy
```

### 8.2 Metadata Use Cases

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              METADATA USE CASES                                      │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│  1. CHANGE DETECTION                                                                │
│     ──────────────────────────────────────────────────────────────                  │
│     "Has this entry's content changed since last check?"                            │
│                                                                                      │
│     old_hash = metadata.content__hash  # '8cdcee46a5'                               │
│     new_hash = safe_str_hash(new_content)                                           │
│     changed = old_hash != new_hash                                                  │
│                                                                                      │
│  2. SIZE TRACKING                                                                   │
│     ──────────────────────────────────────────────────────────────                  │
│     "How much storage is this entry using?"                                         │
│                                                                                      │
│     total_size = sum(m.content__size for m in all_metadata)                         │
│                                                                                      │
│  3. AUDIT TRAIL                                                                     │
│     ──────────────────────────────────────────────────────────────                  │
│     "When was this entry created?"                                                  │
│                                                                                      │
│     created_at = metadata.data.stored_at                                            │
│     strategy_used = metadata.data.strategy                                          │
│                                                                                      │
│  4. VERSION HISTORY                                                                 │
│     ──────────────────────────────────────────────────────────────                  │
│     "What was the previous version of this entry?"                                  │
│                                                                                      │
│     if metadata.previous_version_path:                                              │
│         previous = load(metadata.previous_version_path)                             │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 9. Data Layer Operations (Tier 2)

### 9.1 Storing Data

When a FLeT stores HTML using `data__store_string()`:

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│  FLeT__Html__To__Cache.execute()                                                     │
│                                                                                      │
│  cache_client.data__store_string(                                                   │
│      namespace    = 'test-html-to-cache',                                           │
│      cache_id     = 'a1b2c3d4-...',         ← Entry must already exist!            │
│      data_key     = 'html',                 ← Subfolder in data/                   │
│      data_file_id = 'raw',                  ← Filename                             │
│      content      = '<html>...</html>'      ← The HTML content                     │
│  )                                                                                  │
│                                                                                      │
│  Result: Creates file at:                                                           │
│    data/key-based/test/entity/root/data/html/raw.txt                                │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 9.2 Data Folder Structure

```
root/data/                                       ← Data folder root
│
├── html/                                        ← data_key = 'html'
│   ├── raw.txt                                  ← data_file_id = 'raw'
│   │   Content: <html><body>...</body></html>
│   │
│   ├── cleaned.txt                              ← data_file_id = 'cleaned'
│   │   Content: <html><body>...</body></html>  (whitespace removed)
│   │
│   └── processed.txt                            ← data_file_id = 'processed'
│       Content: <html>...</html>               (scripts removed)
│
├── extracted/                                   ← data_key = 'extracted'
│   ├── links.json                               ← data_file_id = 'links'
│   │   Content: {"links": ["http://...", ...]}
│   │
│   └── text.txt                                 ← data_file_id = 'text'
│       Content: Plain text extracted from HTML
│
├── graph/                                       ← data_key = 'graph'
│   └── mgraph.json                              ← data_file_id = 'mgraph'
│       Content: {"nodes": [...], "edges": [...]}
│
└── metadata/                                    ← data_key = 'metadata'
    └── stats.json                               ← data_file_id = 'stats'
        Content: {"word_count": 1234, "link_count": 56}
```

### 9.3 Data Operation Flow

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                      │
│  PREREQUISITE: Entry must exist (cache_id must be valid)                            │
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────┐    │
│  │  1. Lookup entry by cache_id                                                │    │
│  │     - Read refs/by-id/{cache_id}.json                                       │    │
│  │     - Get file_paths.data_folders[0]                                        │    │
│  │     - Result: 'data/key-based/test/entity/root/data'                        │    │
│  └────────────────────────────────────────────────────────────────────────────┘    │
│                                         │                                           │
│                                         ▼                                           │
│  ┌────────────────────────────────────────────────────────────────────────────┐    │
│  │  2. Build full path                                                         │    │
│  │     data_folder + '/' + data_key + '/' + data_file_id + extension           │    │
│  │     = 'data/key-based/test/entity/root/data/html/raw.txt'                   │    │
│  └────────────────────────────────────────────────────────────────────────────┘    │
│                                         │                                           │
│                                         ▼                                           │
│  ┌────────────────────────────────────────────────────────────────────────────┐    │
│  │  3. Create directories if needed                                            │    │
│  │     mkdir -p 'data/key-based/test/entity/root/data/html/'                   │    │
│  └────────────────────────────────────────────────────────────────────────────┘    │
│                                         │                                           │
│                                         ▼                                           │
│  ┌────────────────────────────────────────────────────────────────────────────┐    │
│  │  4. Write content to file                                                   │    │
│  │     write('data/.../root/data/html/raw.txt', content)                       │    │
│  └────────────────────────────────────────────────────────────────────────────┘    │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 9.4 Retrieving Data

```python
# FLeT__Html__From__Cache.execute()

html_str = cache_client.data__retrieve_string(
    namespace    = 'test-html-to-cache',
    cache_id     = 'a1b2c3d4-...',
    data_key     = 'html',
    data_file_id = 'raw'
)

# Internally:
# 1. Lookup entry refs by cache_id
# 2. Get data_folder path
# 3. Build: data_folder + '/html/raw.txt'
# 4. Read and return content
```

---

## 10. Code Reference

### 10.1 Key Classes and Their Roles

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│  CLASS                                    │  ROLE                                   │
├───────────────────────────────────────────┼─────────────────────────────────────────┤
│                                           │                                         │
│  Html_Cache__Client                       │  High-level wrapper for cache ops       │
│  ├── entry__store()                       │  Create Tier 1 entry                    │
│  ├── entry__retrieve()                    │  Get entry content                      │
│  ├── entry__exists_by_hash()              │  Deduplication check                    │
│  ├── cache_id__from_key()                 │  Key → ID lookup                        │
│  ├── data__store_string()                 │  Tier 2 string storage                  │
│  ├── data__retrieve_string()              │  Tier 2 string retrieval                │
│  └── data__exists()                       │  Check if data file exists              │
│                                           │                                         │
├───────────────────────────────────────────┼─────────────────────────────────────────┤
│                                           │                                         │
│  Cache__Service__Fast_API__Client         │  HTTP client for cache API              │
│  ├── store()                              │  Returns store client                   │
│  ├── retrieve()                           │  Returns retrieve client                │
│  ├── data_store()                         │  Returns data store client              │
│  └── data()                               │  Returns data ops client                │
│                                           │                                         │
├───────────────────────────────────────────┼─────────────────────────────────────────┤
│                                           │                                         │
│  Cache__Service                           │  Core cache logic                       │
│  ├── store_with_strategy()                │  Main storage orchestration             │
│  ├── hash_from_json_field()               │  Calculate hash from JSON field         │
│  └── get_or_create_handler()              │  Get namespace file handler             │
│                                           │                                         │
├───────────────────────────────────────────┼─────────────────────────────────────────┤
│                                           │                                         │
│  Cache__Service__Store__With_Strategy     │  Storage execution                      │
│  ├── execute()                            │  Main orchestration                     │
│  ├── initialize_context()                 │  Set up storage context                 │
│  ├── store_data()                         │  Write entry files                      │
│  ├── update_hash_reference()              │  Write by-hash ref                      │
│  ├── create_file_refs()                   │  Write by-id ref                        │
│  └── build_response()                     │  Create response                        │
│                                           │                                         │
├───────────────────────────────────────────┼─────────────────────────────────────────┤
│                                           │                                         │
│  Cache__Hash__Generator                   │  Hash calculations                      │
│  ├── from_string()                        │  String → cache_hash                    │
│  └── from_bytes()                         │  Bytes → cache_hash                     │
│                                           │                                         │
└───────────────────────────────────────────┴─────────────────────────────────────────┘
```

### 10.2 Schema Classes

```python
# Entry Schema (what gets stored in root.json)
class Schema__Html_Cache__Entry(Type_Safe):
    cache_key : Safe_Str__Cache_Key = ''     # The semantic key (URL, path, etc.)

# Store Response (returned from entry__store)
class Schema__Cache__Store__Response(Type_Safe):
    cache_id  : Cache_Id                     # Generated unique ID
    cache_hash: Safe_Str__Cache_Hash         # Identity hash
    success   : bool                         # Whether storage succeeded
    file_path : str                          # Where entry was stored

# Retrieve Response (returned from entry__retrieve)
class Schema__Cache__Retrieve__Success(Type_Safe):
    data      : dict                         # The entry content
    metadata  : Schema__Cache__Store__Metadata  # Entry metadata
    data_type : str                          # 'json', 'string', 'binary'

# File Refs (stored in by-id reference)
class Schema__Cache__File__Refs(Type_Safe):
    cache_id   : Cache_Id
    cache_hash : Safe_Str__Cache_Hash
    namespace  : Safe_Str__Namespace
    strategy   : str
    file_type  : str
    timestamp  : str
    all_paths  : Schema__All_Paths
    file_paths : Schema__File_Paths
```

### 10.3 Complete Store Example

```python
# Complete example of storing an entry and then storing data

from mgraph_ai_service_html_graph.service.cache_storage.Html_Cache__Client import Html_Cache__Client
from mgraph_ai_service_html_graph.service.flet_pipeline.flet.schemas.Schema__Html_Cache__Entry import Schema__Html_Cache__Entry

# 1. Create client
cache_client = Html_Cache__Client()

# 2. Create entry (Tier 1)
entry = Schema__Html_Cache__Entry()
response = cache_client.entry__store(
    namespace = 'my-namespace',
    cache_key = 'https://example.com/page',
    file_id   = 'root',
    entry     = entry
)

cache_id = response.cache_id  # 'a1b2c3d4-...'

# Files created:
# - my-namespace/data/key-based/https/example.com/page/root.json
# - my-namespace/data/key-based/https/example.com/page/root.json.config
# - my-namespace/data/key-based/https/example.com/page/root.json.metadata
# - my-namespace/refs/by-hash/{aa}/{bb}/{cache_hash}.json
# - my-namespace/refs/by-id/{xx}/{yy}/{cache_id}.json

# 3. Store HTML content (Tier 2)
html = '<html><body><p>Hello World</p></body></html>'
data_response = cache_client.data__store_string(
    namespace    = 'my-namespace',
    cache_id     = cache_id,
    data_key     = 'html',
    data_file_id = 'raw',
    content      = html
)

# File created:
# - my-namespace/data/key-based/https/example.com/page/root/data/html/raw.txt

# 4. Later, retrieve the HTML
retrieved_html = cache_client.data__retrieve_string(
    namespace    = 'my-namespace',
    cache_id     = cache_id,
    data_key     = 'html',
    data_file_id = 'raw'
)

assert retrieved_html == html
```

---

## 11. Troubleshooting Guide

### 11.1 Common Issues

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│  ISSUE: "Entry not found" when using cache_key                                       │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│  Symptom: cache_id__from_key() returns None                                         │
│                                                                                      │
│  Possible causes:                                                                   │
│  1. Entry was never created                                                         │
│     → Check: Does refs/by-hash/{hash}.json exist?                                   │
│                                                                                      │
│  2. Different cache_key was used                                                    │
│     → The hash of 'https://example.com' != hash of 'https://example.com/'           │
│     → Trailing slashes, protocol differences matter!                                │
│                                                                                      │
│  3. Wrong namespace                                                                 │
│     → Each namespace has separate refs/                                             │
│                                                                                      │
│  Debug steps:                                                                       │
│    cache_hash = hash_generator.from_string(cache_key)                               │
│    print(f"Looking for: refs/by-hash/{cache_hash[0:2]}/{cache_hash[2:4]}/...")     │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│  ISSUE: "Data not found" when retrieving from Tier 2                                 │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│  Symptom: data__retrieve_string() returns None                                      │
│                                                                                      │
│  Possible causes:                                                                   │
│  1. Data was never stored                                                           │
│     → data__store_string() was never called                                         │
│                                                                                      │
│  2. Wrong data_key or data_file_id                                                  │
│     → 'html/raw' vs 'html' + 'raw' confusion                                        │
│                                                                                      │
│  3. Entry exists but data folder is empty                                           │
│     → Check: Does {entry}/root/data/ contain files?                                 │
│                                                                                      │
│  Debug steps:                                                                       │
│    refs = cache_client.cache__entry__refs(cache_id, namespace)                      │
│    print(refs.file_paths.data_folders)  # Should show data folder path             │
│    # Then manually check if data_key/data_file_id exists there                      │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│  ISSUE: Duplicate entries for same URL                                               │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│  Symptom: Multiple cache_ids exist for what should be the same content              │
│                                                                                      │
│  Possible causes:                                                                   │
│  1. Not checking entry__exists_by_hash() before creating                            │
│     → Always check deduplication first!                                             │
│                                                                                      │
│  2. Different normalization of cache_key                                            │
│     → 'HTTP://Example.COM' vs 'http://example.com'                                  │
│                                                                                      │
│  3. Different json_field_path used                                                  │
│     → If hashing different fields, different hashes result                          │
│                                                                                      │
│  Prevention:                                                                        │
│    # Always check first                                                             │
│    cache_hash = hash_generator.from_string(normalized_url)                          │
│    if cache_client.entry__exists_by_hash(namespace, cache_hash):                    │
│        cache_id = cache_client.cache_id__from_key(namespace, normalized_url)        │
│    else:                                                                            │
│        response = cache_client.entry__store(...)                                    │
│        cache_id = response.cache_id                                                 │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 11.2 Diagnostic Queries

```python
# Get all info about an entry
def diagnose_entry(cache_client, cache_id, namespace):
    entry_data = cache_client.entry__retrieve(cache_id, namespace)
    entry_refs = cache_client.cache__entry__refs(cache_id, namespace)
    entry_meta = cache_client.cache__entry__metadata(cache_id, namespace)
    
    print(f"Entry Data:     {entry_data}")
    print(f"Cache Hash:     {entry_refs.cache_hash}")
    print(f"Data Folders:   {entry_refs.file_paths.data_folders}")
    print(f"Content Hash:   {entry_meta.content__hash}")
    print(f"Content Size:   {entry_meta.content__size}")
    print(f"Created At:     {entry_meta.data.stored_at}")

# List all data files for an entry
def list_entry_data(cache_client, cache_id, namespace):
    data_list = cache_client.data__list(namespace, cache_id)
    for item in data_list.files:
        print(f"  {item.data_key}/{item.data_file_id} ({item.size} bytes)")
```

---

## Summary

The MGraph Cache Service implements a sophisticated two-tier storage model:

1. **Tier 1 (Entry Storage)**: Creates the entity identity with entry file, config, metadata, and dual reference indexes (by-hash and by-id)

2. **Tier 2 (Data Storage)**: Stores actual content within the entity's data folder, supporting multiple data types and flexible organization

3. **Hash-based Identity**: Uses `cache_hash` derived from `cache_key` (typically URL) for deduplication, while `cache_id` (GUID) provides stable references

4. **Reference System**: Maintains two indexes for O(1) lookups - by-hash for deduplication checks, by-id for direct retrieval

5. **Metadata Tracking**: Records content hashes, timestamps, and storage configuration for auditing and change detection

This architecture enables efficient caching of web content with proper deduplication, fast lookups, and flexible data organization for downstream processing (FLeTs, transformations, etc.).
