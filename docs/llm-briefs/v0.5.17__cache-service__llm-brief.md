# MGraph-AI Cache Service - LLM Brief

## Service Overview
The MGraph-AI Cache Service is a production-ready, serverless caching system designed for AWS Lambda deployment. It provides intelligent content-addressable storage with multiple caching strategies, backed by AWS S3 with Memory-FS abstraction layer.

## Core Architecture

### Service Structure
- **FastAPI-based**: Built on `osbot-fast-api-serverless` framework
- **AWS Lambda optimized**: Includes dependency loading and cold-start optimization
- **Type-safe**: Extensive use of `Type_Safe` classes for validation
- **Modular design**: Clear separation between service, storage, and API layers

### Storage Backend
- **S3 Storage**: Primary backend via `Storage_FS__S3` class
- **Memory-FS abstraction**: File system operations through `Memory_FS` library
- **Path sharding**: Automatic 2-level hash sharding for S3 performance
- **Namespace isolation**: Each namespace maps to an S3 prefix

## Storage Strategies

The service implements four distinct storage strategies through different `Memory_FS` implementations:

### 1. Direct (`direct`)
- Simple hash-based storage at `data/direct/`
- Uses `Memory_FS` with `Path__Handler__Hash_Sharded`
- Best for: Simple key-value storage without versioning

### 2. Temporal (`temporal`)
- Time-organized storage at `data/temporal/`
- Uses `Memory_FS__Temporal` for automatic timestamping
- Best for: Time-series data, audit logs

### 3. Temporal Latest (`temporal_latest`)
- Temporal storage with latest pointer at `data/temporal-latest/`
- Uses `Memory_FS__Latest_Temporal`
- Best for: Frequently updated content where you need both history and quick latest access

### 4. Temporal Versioned (`temporal_versioned`)
- Full versioning system at `data/temporal-versioned/`
- Maintains versions at `data/temporal-versioned/versions/`
- Uses combined handlers: temporal, latest, and versioned
- Best for: Complete version history with rollback capability

## API Endpoints

### Storage Operations

#### String Storage
```
POST /cache/store/string/{strategy}/{namespace}
```
- Body: Raw string data
- Auto-generates hash from content
- Returns: `Schema__Cache__Store__Response`

#### JSON Storage
```
POST /cache/store/json/{strategy}/{namespace}
```
- Body: JSON object
- Sorted keys for consistent hashing
- Returns: `Schema__Cache__Store__Response`

#### Binary Storage
```
POST /cache/store/binary/{strategy}/{namespace}
```
- Body: Raw binary data
- Supports `Content-Encoding: gzip` header
- Auto-decompresses for hash calculation if compressed
- Returns: `Schema__Cache__Store__Response`

### Retrieval Operations

#### Generic Retrieval (with metadata)
```
GET /cache/retrieve/by-hash/{cache_hash}/{namespace}
GET /cache/retrieve/by-id/{cache_id}/{namespace}
```
- Returns data with type information and metadata
- Binary data returns URL redirect instead of inline data

#### Type-Specific Retrieval
```
# By ID
GET /cache/retrieve/string/by-id/{cache_id}/{namespace}
GET /cache/retrieve/json/by-id/{cache_id}/{namespace}
GET /cache/retrieve/binary/by-id/{cache_id}/{namespace}

# By Hash
GET /cache/retrieve/string/by-hash/{cache_hash}/{namespace}
GET /cache/retrieve/json/by-hash/{cache_hash}/{namespace}
GET /cache/retrieve/binary/by-hash/{cache_hash}/{namespace}
```
- Returns data in appropriate format
- Binary endpoints return `application/octet-stream`
- String endpoints return `text/plain`
- JSON endpoints return parsed JSON

### Management Operations
```
GET /cache/exists/{cache_hash}/{namespace}
GET /cache/namespaces
GET /cache/stats/namespaces/{namespace}
GET /cache/stats/namespaces
DELETE /cache/delete/by-id/{cache_id}/{namespace}
```

### Service Information
```
GET /info/health          # Returns: {'status': 'ok'}
GET /info/server          # Server info including Fast_API details
GET /info/status          # Service status with environment
GET /info/versions        # All dependency versions
```

## Data Model

### Cache Hash (`Safe_Str__Cache_Hash`)
- Format: Lowercase hexadecimal, 10-96 characters
- Default length: 16 characters
- Configurable via `Cache__Hash__Config`
- Algorithms: MD5, SHA256 (default), SHA384

### Cache ID (`Random_Guid`)
- Format: Standard UUID/GUID
- Unique per storage operation
- Used for direct retrieval and deletion

### Storage Structure

#### Reference Stores
1. **Hash References** (`refs/by-hash/`)
   - Maps hash → list of cache IDs
   - Tracks latest_id and total_versions
   - Sharded path: `aa/bb/{hash}.json`

2. **ID References** (`refs/by-id/`)
   - Maps cache ID → hash and metadata
   - Stores all file paths and strategy info
   - Sharded path: `aa/bb/{cache_id}.json`

#### Data Storage
- Location depends on strategy
- Files stored as `.json` or `.binary` based on content type
- Metadata stored in `.metadata` files

## Response Schemas

### Store Response (`Schema__Cache__Store__Response`)
```json
{
  "cache_id": "uuid-format",
  "hash": "16-char-hash",
  "paths": {
    "data": ["path/to/data/files"],
    "by_hash": ["refs/by-hash/paths"],
    "by_id": ["refs/by-id/paths"]
  },
  "size": 12345
}
```

### Retrieve Response (with metadata)
```json
{
  "data": "<content>",
  "metadata": {
    "cache_hash": "hash",
    "cache_id": "uuid",
    "cache_key_data": "original-key",
    "stored_at": "timestamp",
    "strategy": "temporal_latest",
    "namespace": "default",
    "file_type": "json|binary|string",
    "content_encoding": "gzip"
  },
  "data_type": "json|binary|string"
}
```

### Stats Response
```json
{
  "namespace": "default",
  "s3_bucket": "mgraph-ai-cache",
  "s3_prefix": "namespace-name",
  "ttl_hours": 24,
  "direct_files": 0,
  "temporal_files": 10,
  "temporal_latest_files": 5,
  "temporal_versioned_files": 15,
  "refs_hash_files": 20,
  "refs_id_files": 30,
  "total_files": 80
}
```

## Implementation Details

### Request Body Handling
- Uses custom `BodyReaderMiddleware` for async body reading
- Body stored in `request.state.body` for sync access
- Supports POST, PUT, PATCH methods

### Hash Generation (`Cache__Hash__Generator`)
- Consistent hashing across data types
- JSON: Sorted keys for deterministic hashing
- Strings: UTF-8 encoded before hashing
- Binary: Direct hash calculation
- Type_Safe objects: Converted to JSON first

### Compression Support
- Auto-detects `Content-Encoding: gzip`
- Decompresses for hash calculation
- Stores compressed version for efficiency
- Transparent decompression on retrieval

### Namespace Management
- Dynamic namespace creation
- Default namespace: "default"
- Each namespace has isolated:
  - S3 prefix
  - TTL settings (default: 24 hours)
  - Storage handlers

## AWS Lambda Deployment

### Configuration
- Handler: `mgraph_ai_service_cache.fast_api.lambda_handler.run`
- Dependencies loaded via `boto3__lambda.load_dependencies()`
- Environment detection via `AWS_REGION` variable

### Dependencies
```python
LAMBDA_DEPENDENCIES__FAST_API_SERVERLESS = [
    'osbot-fast-api-serverless==v1.17.0',
    'memory-fs==0.20.0'
]
```

### Deployment Class
- `Deploy__Service` extends `Deploy__Serverless__Fast_API`
- Service name: `mgraph_ai_service_cache`
- Supports environment variable configuration

## Best Practices

### Content Type Selection
- **String**: Plain text, logs, simple values
- **JSON**: Structured data, API responses
- **Binary**: Files, compressed data, images

### Strategy Selection
- **High read, rare update**: Use `temporal_latest`
- **Audit requirements**: Use `temporal_versioned`
- **Simple caching**: Use `direct`
- **Time-series data**: Use `temporal`

### Performance Optimization
- Hash sharding distributes S3 load
- Compression reduces storage and transfer
- Reference stores enable fast lookups
- Namespace isolation prevents cross-contamination

### Error Handling
- Returns 404 for missing content
- Graceful handling of compression errors
- Type conversion attempts for format mismatches
- Partial deletion tracking in delete operations

## Security Considerations

### S3 Permissions Required
- `s3:GetObject`
- `s3:PutObject`
- `s3:DeleteObject`
- `s3:ListBucket`
- `s3:GetObjectMetadata`
- `s3:PutObjectMetadata`

### Data Isolation
- Complete namespace isolation
- No cross-namespace retrieval
- Separate S3 prefixes per namespace

## Version Information
- Current version: v0.5.15
- Python package: `mgraph_ai_service_cache`
- FastAPI framework with OpenAPI 3.1.0
- AWS Lambda runtime compatible

## Integration Examples

### Python Client Example
```python
import requests
import json

class CacheClient:
    def __init__(self, base_url="https://cache.dev.mgraph.ai"):
        self.base_url = base_url
    
    def store_json(self, data, strategy="temporal_latest", namespace="default"):
        response = requests.post(
            f"{self.base_url}/cache/store/json/{strategy}/{namespace}",
            json=data
        )
        return response.json()
    
    def retrieve_by_hash(self, cache_hash, namespace="default"):
        response = requests.get(
            f"{self.base_url}/cache/retrieve/by-hash/{cache_hash}/{namespace}"
        )
        return response.json()
    
    def delete_by_id(self, cache_id, namespace="default"):
        response = requests.delete(
            f"{self.base_url}/cache/delete/by-id/{cache_id}/{namespace}"
        )
        return response.json()
```

### Handling Binary Data with Compression
```python
import gzip
import requests

def cache_compressed_file(file_path, namespace="files"):
    with open(file_path, 'rb') as f:
        content = f.read()
    
    # Compress before sending
    compressed = gzip.compress(content)
    
    response = requests.post(
        f"https://cache.dev.mgraph.ai/cache/store/binary/temporal_versioned/{namespace}",
        data=compressed,
        headers={"Content-Encoding": "gzip"}
    )
    
    return response.json()
```